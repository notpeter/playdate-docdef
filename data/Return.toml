# The SDK documentation does not define these in a machine readable way.
# These return types have been created by hand by Peter Tripp
# and subsequent contributors to this repository.
#
# Note: This TOML file requires a parser which preserves order of HashMaps.
#       features = ["preserve_order"] for Rust `toml` crate
#       will generate IndexMap instead of HashMap.
#
# Note: Sections containing "." (nearly all) must be quoted to avoid
#      being interpreted as nested structures.
#
# Note: `= {"x"="integer"}` generates `---@return integer x
# Note: `= {""="integer"} ` generates `---@return integer
# Note: `= {}`              generates `---@return nil`

["json"] # TODO: What happens if these fail? Return nil?
".decode(string)" = {json_object="table"}
".decodeFile(file)" = {json_object="table"}
".decodeFile(path)" = {json_object="table"}
".encode(table)" = {json_string="string"}
".encodePretty(table)" = {json_string="string"}
".encodeToFile(file, pretty, table)" = {}
".encodeToFile(path, pretty, table)" = {}

["playdate"]
".AButtonDown()" = {}
".AButtonHeld()" = {}
".AButtonUp()" = {}
".BButtonDown()" = {}
".BButtonHeld()" = {}
".BButtonUp()" = {}
".GMTTimeFromEpoch(seconds, milliseconds)" = {dt_table="table|DateTime"}
".accelerometerIsRunning()" = {""="boolean"}
".apiVersion()" = {"api_version"="integer", "runtime_minimum_api_version"="integer"}
".buttonIsPressed(button)" = {""="boolean"}
".buttonJustPressed(button)" = {""="boolean"}
".buttonJustReleased(button)" = {""="boolean"}
".clearConsole()" = {}
".crankDocked()" = {}
".crankUndocked()" = {}
".cranked(change, acceleratedChange)" = {}
".debugDraw()" = {}
".deviceDidUnlock()" = {}
".deviceWillLock()" = {}
".deviceWillSleep()" = {}
".downButtonDown()" = {}
".downButtonUp()" = {}
".drawFPS(x, y)" = {}
".epochFromGMTTime(time)" = {seconds="integer", milliseconds="integer"}
".epochFromTime(time)" = {seconds="integer", milliseconds="integer"}
".gameWillPause()" = {}
".gameWillResume()" = {}
".gameWillTerminate()" = {}
".getBatteryPercentage()" = {percent="integer"}
".getBatteryVoltage()" = {volts="number"}
".getButtonState()" = {current="integer", pressed="integer", released="integer"}
".getCrankChange()" = {"degrees"="number"}
".getCrankPosition()" = {"degrees"="number"}
".getCrankTicks(ticksPerRevolution)" = {"ticks"="number"}
".getCurrentTimeMilliseconds()" = {milliseconds_active="integer"}
".getElapsedTime()" = {seconds="number"}
".getFPS()" = {fps="number"}
".getFlipped()" = {"flipped"="boolean"}
".getGMTTime()" = {dt_table="table|DateTime"}
".getPowerStatus()" = {status_table="table|PowerStatus"}
".getReduceFlashing()" = {"reduceFlashing"="boolean"}
".getSecondsSinceEpoch()" = {seconds="integer", milliseconds="integer"}
".getStats()" = {stats_table="table|SystemStats"}
".getSystemLanguage()" = {"language"="integer"} # 0=en|1=ja
".getSystemMenu()" = {menu="playdate.menu"}
".getTime()" = {dt_table="table|DateTime"}
".inputHandlers.pop()" = {} # TODO: Check if this returns the input handled
".inputHandlers.push(handler, masksPreviousHandlers)" = {}
".isCrankDocked()" = {""="boolean"}
".keyPressed(key)" = {}
".keyReleased(key)" = {}
".leftButtonDown()" = {}
".leftButtonUp()" = {}
".readAccelerometer()" = {x="number", y="number", z="number"}
".resetElapsedTime()" = {}
".rightButtonDown()" = {}
".rightButtonUp()" = {}
".setAutoLockDisabled(disable)" = {}
".setCollectsGarbage(flag)" = {}
".setCrankSoundsDisabled(disable)" = {}
".setDebugDrawColor(r, g, b, a)" = {}
".setGCScaling(min, max)" = {}
".setMenuImage(image, xOffset)" = {}
".setMinimumGCTime(ms)" = {}
".setNewlinePrinted(flag)" = {}
".setStatsInterval(seconds)" = {}
".shouldDisplay24HourTime()" = {""="boolean"}
".start()" = {}
".startAccelerometer()" = {}
".stop()" = {}
".stopAccelerometer()" = {}
".timeFromEpoch(seconds, milliseconds)" = {dt_table="table|DateTime"}
".upButtonDown()" = {}
".upButtonUp()" = {}
".update()" = {}
".wait(milliseconds)" = {}

["playdate.datastore"]
".delete(filename)" = {success="boolean"}
".read(filename)" = {""="table?"}
".readImage(path)" = {""="playdate.graphics.image?"}
".write(tbl, filename, pretty)" = {} # TODO: Check if returns on failure.
".writeImage(image, path)" = {} # TODO: Check if returns on failure.

["playdate.display"]
".flush()" = {}
".getHeight()" = {pixels="integer"}
".getInverted()" = {inverted="boolean"}
".getMosaic()" = {x="integer", y="integer"}
".getOffset()" = {x="integer", y="integer"}
".getRect()" = {rect="playdate.geometry.rect"}
".getRefreshRate()" = {fps="integer"}
".getScale()" = {scale="integer"}
".getSize()" = {width="integer", height="integer"}
".getWidth()" = {pixels="integer"}
".loadImage(path)" = {}
".setFlipped(x, y)" = {}
".setInverted(flag)" = {}
".setMosaic(x, y)" = {}
".setOffset(x, y)" = {}
".setRefreshRate(rate)" = {}
".setScale(scale)" = {}

["playdate.easingFunctions"]
".linear fun(t, b, c, d)" = {""="number"}
".inQuad fun(t, b, c, d)" = {""="number"}
".outQuad fun(t, b, c, d)" = {""="number"}
".inOutQuad fun(t, b, c, d)" = {""="number"}
".outInQuad fun(t, b, c, d)" = {""="number"}
".inCubic fun(t, b, c, d)" = {""="number"}
".outCubic fun(t, b, c, d)" = {""="number"}
".inOutCubic fun(t, b, c, d)" = {""="number"}
".outInCubic fun(t, b, c, d)" = {""="number"}
".inQuart fun(t, b, c, d)" = {""="number"}
".outQuart fun(t, b, c, d)" = {""="number"}
".inOutQuart fun(t, b, c, d)" = {""="number"}
".outInQuart fun(t, b, c, d)" = {""="number"}
".inQuint fun(t, b, c, d)" = {""="number"}
".outQuint fun(t, b, c, d)" = {""="number"}
".inOutQuint fun(t, b, c, d)" = {""="number"}
".outInQuint fun(t, b, c, d)" = {""="number"}
".inSine fun(t, b, c, d)" = {""="number"}
".outSine fun(t, b, c, d)" = {""="number"}
".inOutSine fun(t, b, c, d)" = {""="number"}
".outInSine fun(t, b, c, d)" = {""="number"}
".inExpo fun(t, b, c, d)" = {""="number"}
".outExpo fun(t, b, c, d)" = {""="number"}
".inOutExpo fun(t, b, c, d)" = {""="number"}
".outInExpo fun(t, b, c, d)" = {""="number"}
".inCirc fun(t, b, c, d)" = {""="number"}
".outCirc fun(t, b, c, d)" = {""="number"}
".inOutCirc fun(t, b, c, d)" = {""="number"}
".outInCirc fun(t, b, c, d)" = {""="number"}
".inElastic fun(t, b, c, d, a?, p?)" = {""="number"}
".outElastic fun(t, b, c, d, a?, p?)" = {""="number"}
".inOutElastic fun(t, b, c, d, a?, p?)" = {""="number"}
".outInElastic fun(t, b, c, d, a?, p?)" = {""="number"}
".inBack fun(t, b, c, d, s?)" = {""="number"}
".outBack fun(t, b, c, d, s?)" = {""="number"}
".inOutBack fun(t, b, c, d, s?)" = {""="number"}
".outInBack fun(t, b, c, d, s?)" = {""="number"}
".outBounce fun(t, b, c, d)" = {""="number"}
".inBounce fun(t, b, c, d)" = {""="number"}
".inOutBounce fun(t, b, c, d)" = {""="number"}
".outInBounce fun(t, b, c, d)" = {""="number"}

["playdate.file"]
".delete(path, recursive)" = {success="boolean"}
".exists(path)" = {""="boolean"}
".isdir(path)" = {""="boolean"}
".listFiles(path, showhidden)" = {files="string[]"}
".load(path, env)" = {""="function"}
".mkdir(path)" = {} # TODO: Check if this returns. C has returns.
".getSize(path)" = {"bytes"="integer"}
".getType(path)" = {""="string"} # TODO: Confirm this.
".modtime(path)" = {""="ModTime|table"}
".open(path, mode)" = {"file"="playdate.file.file?", "error"="string?"}
".rename(path, newPath)" = {success="boolean"}
".run(path, env)" = {}

["playdate.file.file"]
":close()" = {} # TODO: Check if this returns. C has returns.
":write(string)" = {bytes_written="integer", error="string?"}
":flush()" = {} # TODO: Check if this returns. C has returns.
":readline()" = {line="string"}
":read(numberOfBytes)" = {numberOfBytes="integer", error="string"}
":seek(offset)" = {} # TODO: Check if this returns. C has returns.
":tell()" = {offset="integer"}

["playdate.geometry.affineTransform"]
".new" = {transform="playdate.geometry.affineTransform"}
".new(m11, m12, m21, m22, tx, ty)" = {transform="playdate.geometry.affineTransform"}
":copy()" = {transform="playdate.geometry.affineTransform"}
":invert()" = {}
":reset()" = {}
":concat(af)" = {}
":translate(dx, dy)" = {}
":translatedBy(dx, dy)" = {affineTransform="playdate.geometry.affineTransform"}
":scale(sx, sy)" = {}
":scaledBy(sx, sy)" = {affineTransform="playdate.geometry.affineTransform"}
":rotate(angle, x, y)" = {}
":rotate(angle, point)" = {}
":rotatedBy(angle, x, y)" = {affineTransform="playdate.geometry.affineTransform"}
":rotatedBy(angle, point)" = {affineTransform="playdate.geometry.affineTransform"}
":skew(sx, sy)" = {}
":skewedBy(sx, sy)" = {affineTransform="playdate.geometry.affineTransform"}
":transformPoint(p)" = {}
":transformedPoint(p)" = {point="playdate.geometry.point"}
":transformXY(x, y)" = {x="number", y="number"}
":transformLineSegment(ls)" = {}
":transformedLineSegment(ls)" = {lineSegment="playdate.geometry.lineSegment"}
":transformAABB(r)" = {}
":transformedAABB(r)" = {rect="playdate.geometry.rect"}
":transformPolygon(p)" = {}
":transformedPolygon(p)" = {polygon="playdate.geometry.polygon"}
":__mul(other)" = {affineTransform="playdate.geometry.affineTransform"}
":__mul(vector)" = {vector="playdate.geometry.vector"}
":__mul(point)" = {point="playdate.geometry.point"}

["playdate.geometry"]
".squaredDistanceToPoint(x1, y1, x2, y2)" = {distanceSquared="number"}
".distanceToPoint(x1, y1, x2, y2)" = {distance="number"}

["playdate.geometry.arc"]
".new(x, y, radius, startAngle, endAngle, direction)" = {arc="playdate.geometry.arc"}
":copy()" = {arc="playdate.geometry.arc"}
":length()" = {""="number"}
":isClockwise()" = {""="boolean"}
":setIsClockwise(flag)" = {}
":pointOnArc(distance, extend)" = {""="playdate.geometry.point"}

["playdate.geometry.lineSegment"]
".fast_intersection(x1, y1, x2, y2, x3, y3, x4, y4)" = {intersects="boolean", x="number?", y="number?"}
".new(x1, y1, x2, y2)" = {lineSegment="playdate.geometry.lineSegment"}
":copy()" = {lineSegment="playdate.geometry.lineSegment"}
":unpack()" = {x1="number", y1="number", x2="number", y2="number"}
":length()" = {length="number"}
":offset(dx, dy)" = {}
":offsetBy(dx, dy)" = {lineSegment="playdate.geometry.lineSegment"}
":midPoint()" = {point="playdate.geometry.point"}
":pointOnLine(distance, extend)" = {point="playdate.geometry.point"}
":segmentVector()" = {vector="playdate.geometry.vector2D"}
":closestPointOnLineToPoint(p)" = {point="playdate.geometry.point"}
":intersectsLineSegment(ls)" = {intersects="boolean", intersection="playdate.geometry.point?"}
":intersectsPolygon(poly)" = {intersects="boolean", intersectionPoints="playdate.geometry.point[]?"}
":intersectsRect(rect)" = {intersects="boolean", intersectionPoints="playdate.geometry.point[]?"}

["playdate.geometry.point"]
".new(x, y)" = {point="playdate.geometry.point"}
":copy()" = {point="playdate.geometry.point"}
":unpack()" = {x="number", y="number"}
":offset(dx, dy)" = {}
":offsetBy(dx, dy)" = {point="playdate.geometry.point"}
":squaredDistanceToPoint(p)" = {distanceSquared="number"}
":distanceToPoint(p)" = {distance="number"}
":__add(v)" = {point="playdate.geometry.point"}
":__sub(p2)" = {vector="playdate.geometry.vector2D"}
":__mul(t)" = {point="playdate.geometry.point"}
":__concat(p2)" = {lineSegment="playdate.geometry.lineSegment"}

["playdate.geometry.polygon"]
".new(x1, y1, x2, y2, ...)" = {polygon="playdate.geometry.polygon"}
".new(p1, p2, ...)" = {polygon="playdate.geometry.polygon"}
".new(numberOfVertices)" = {polygon="playdate.geometry.polygon"}
":copy()" = {polygon="playdate.geometry.polygon"}
":close()" = {}
":isClosed()" = {""="boolean"}
":containsPoint(p, fillRule)" = {""="boolean"}
":containsPoint(x, y, fillRule)" = {""="boolean"}
":getBounds()" = {x="number", y="number", width="number", height="number"}
":getBoundsRect()" = {rect="playdate.geometry.rect"}
":count()" = {""="integer"}
":length()" = {""="number"}
":setPointAt(n, x, y)" = {}
":getPointAt(n)" = {point="playdate.geometry.point"}
":intersects(p)" = {""="boolean"}
":pointOnPolygon(distance, extend)" = {point="playdate.geometry.point"}
":translate(dx, dy)" = {}
":__mul(t)" = {polygon="playdate.geometry.polygon"}

["playdate.geometry.rect"]
".fast_intersection(x1, y1, w1, h1, x2, y2, w2, h2)" = {x="number", y="number", width="number", height="number"}
".fast_union(x1, y1, w1, h1, x2, y2, w2, h2)" = {x="number", y="number", width="number", height="number"}
".new(x, y, width, height)" = {""="playdate.geometry.rect"}
":copy()" = {rect="playdate.geometry.rect"}
":toPolygon()" = {polygon="playdate.geometry.polygon"}
":unpack()" = {x="number", y="number", width="number", height="number"}
":isEmpty()" = {""="boolean"}
":isEqual(r2)" = {""="boolean"}
":intersects(r2)" = {""="boolean"}
":intersection(r2)" = {rect="playdate.geometry.rect"}
":union(r2)" = {rect="playdate.geometry.rect"}
":inset(dx, dy)" = {}
":insetBy(dx, dy)" = {rect="playdate.geometry.rect"}
":offset(dx, dy)" = {}
":offsetBy(dx, dy)" = {rect="playdate.geometry.rect"}
":containsRect(r2)" = {""="boolean"}
":containsRect(x, y, width, height)" = {""="boolean"}
":containsPoint(p)" = {""="boolean"}
":containsPoint(x, y)" = {""="boolean"}
":centerPoint()" = {"point"="playdate.geometry.point"}
":flipRelativeToRect(r2, flip)" = {}

["playdate.geometry.size"]
".new(width, height)" = {size="playdate.geometry.size"}
":copy()" = {size="playdate.geometry.size"}
":unpack()" = {width="number", height="number"}

["playdate.geometry.vector2D"]
".new(x, y)" = {vector="playdate.geometry.vector2D"}
".newPolar(length, angle)" = {vector="playdate.geometry.vector2D"}
":copy()" = {vector="playdate.geometry.vector2D"}
":unpack()" = {x="number", y="number"}
":addVector(v)" = {}
":scale(s)" = {}
":scaledBy(s)" = {vector="playdate.geometry.vector2D"}
":normalize()" = {}
":normalized()" = {vector="playdate.geometry.vector2D"}
":dotProduct(v)" = {"dotProduct"="number"}
":magnitude()" = {"magnitude"="number"}
":magnitudeSquared()" = {"magnitudeSquared"="number"}
":projectAlong(v)" = {}
":projectedAlong(v)" = {vector="playdate.geometry.vector2D"}
":angleBetween(v)" = {degrees="number"}
":leftNormal()" = {vector="playdate.geometry.vector2D"}
":rightNormal()" = {vector="playdate.geometry.vector2D"}
":__unm()" = {vector="playdate.geometry.vector2D"}
":__add(v2)" = {vector="playdate.geometry.vector2D"}
":__sub(v2)" = {vector="playdate.geometry.vector2D"}
":__mul(s)" = {vector="playdate.geometry.vector2D"}
":__mul(v2)" = {vector="playdate.geometry.vector2D"}
":__mul(t)" = {vector="playdate.geometry.vector2D"}
":__div(s)" = {vector="playdate.geometry.vector2D"}

["playdate.graphics"]
".checkAlphaCollision(image1, x1, y1, flip1, image2, x2, y2, flip2)" = {""="boolean"}
".clear(color)" = {}
".clearClipRect()" = {}
".clearStencil()" = {}
".clearStencilImage()" = {}
".drawArc(arc)" = {}
".drawArc(x, y, radius, startAngle, endAngle)" = {}
".drawCircleAtPoint(p, radius)" = {}
".drawCircleAtPoint(x, y, radius)" = {}
".drawCircleInRect(r)" = {}
".drawCircleInRect(x, y, width, height)" = {}
".drawEllipseInRect(rect, startAngle, endAngle)" = {}
".drawEllipseInRect(x, y, width, height, startAngle, endAngle)" = {}
".drawLine(x1, y1, x2, y2)" = {}
".drawLocalizedText(key, x, y, language, leadingAdjustment)" = {}
".drawLocalizedTextAligned(text, x, y, alignment, language, leadingAdjustment)" = {}
".drawLocalizedTextInRect(text, rect, leadingAdjustment, truncationString, alignment, font, language)" = {}
".drawLocalizedTextInRect(text, x, y, width, height, leadingAdjustment, truncationString, alignment, font, language)" = {}
".drawPixel(x, y)" = {}
".drawPolygon(p)" = {}
".drawPolygon(x1, y1, x2, y2, ...)" = {}
".drawRect(r)" = {}
".drawRect(x, y, w, h)" = {}
".drawRoundRect(r, radius)" = {}
".drawRoundRect(x, y, w, h, radius)" = {}
".drawSineWave(startX, startY, endX, endY, startAmplitude, endAmplitude, period, phaseShift)" = {}
".drawText(text, x, y, fontFamily, leadingAdjustment)" = {}
".drawTextAligned(text, x, y, alignment, leadingAdjustment)" = {}
".drawTextInRect(text, rect, leadingAdjustment, truncationString, alignment, font)" = {}
".drawTextInRect(text, x, y, width, height, leadingAdjustment, truncationString, alignment, font)" = {}
".drawTriangle(x1, y1, x2, y2, x3, y3)" = {}
".fillCircleAtPoint(p, radius)" = {}
".fillCircleAtPoint(x, y, radius)" = {}
".fillCircleInRect(r)" = {}
".fillCircleInRect(x, y, width, height)" = {}
".fillEllipseInRect(rect, startAngle, endAngle)" = {}
".fillEllipseInRect(x, y, width, height, startAngle, endAngle)" = {}
".fillPolygon(p)" = {}
".fillPolygon(x1, y1, x2, y2, ...)" = {}
".fillRect(r)" = {}
".fillRect(x, y, width, height)" = {}
".fillRoundRect(r, radius)" = {}
".fillRoundRect(x, y, w, h, radius)" = {}
".fillTriangle(x1, y1, x2, y2, x3, y3)" = {}
".generateQRCode(stringToEncode, desiredEdgeDimension, callback)" = {}
".getBackgroundColor()" = {color="integer"}
".getClipRect()" = {x="integer", y="integer", width="integer", height="integer"}
".getColor()" = {color="integer"}
".getDisplayImage()" = {image="playdate.graphics.image"}
".getDrawOffset()" = {x="integer", y="integer"}
".getFont(variant)" = {""="playdate.graphics.font"}
".getFontTracking()" = {""="integer"}
".getImageDrawMode()" = {draw_mode="integer"} # TODO: DrawMode
".getLineWidth()" = {width="integer"}
".getLocalizedText(key, language)" = {""="string"}
".getScreenClipRect()" = {x="integer", y="integer", width="integer", height="integer"}
".getStrokeLocation()" = {strokeLocation="integer"} # TODO: StrokeLocation
".getSystemFont(variant)" = {""="playdate.graphics.font"}
".getTextSize(str, fontFamily, leadingAdjustment)" = {width="integer", height="integer"}
".getTextSizeForMaxWidth(text, maxWidth, leadingAdjustment, font)" = {width="integer", height="integer"}
".getWorkingImage()" = {image="playdate.graphics.image"}
".imageSizeAtPath(path)" = {width="integer", height="integer"} # TODO: Check what happens on failure
".imageWithText(text, maxWidth, maxHeight, backgroundColor, leadingAdjustment, truncationString, alignment, font)" = {image="playdate.graphics.image", textWasTruncated="boolean"}
".lockFocus(image)" = {}
".perlin(x, y, z, _repeat, octaves, persistence)" = {perlin_value="number"}
".perlinArray(count, x, dx, y, dy, z, dz, _repeat, octaves, persistence)" = {perlin_values="number[]"}
".popContext()" = {}
".pushContext(image)" = {}
".setBackgroundColor(color)" = {}
".setClipRect(rect)" = {}
".setClipRect(x, y, width, height)" = {}
".setColor(color)" = {}
".setDitherPattern(alpha, ditherType)" = {}
".setDrawOffset(x, y)" = {}
".setFont(font, variant)" = {}
".setFontFamily(fontFamily)" = {}
".setFontTracking(pixels)" = {}
".setImageDrawMode(mode)" = {}
".setLineCapStyle(style)" = {}
".setLineWidth(width)" = {}
".setPattern(pattern)" = {}
".setPolygonFillRule(rule)" = {}
".setScreenClipRect(rect)" = {}
".setScreenClipRect(x, y, width, height)" = {}
".setStencilImage(image, tile)" = {}
".setStencilPattern(level, ditherType)" = {}
".setStencilPattern(pattern)" = {}
".setStencilPattern(row1, row2, row3, row4, row5, row6, row7, row8)" = {}
".setStrokeLocation(location)" = {}
".unlockFocus()" = {}

["playdate.graphics.animator"]
".new(duration, startValue, endValue, easingFunction, startTimeOffset)" = {""="playdate.graphics.animator"}
".new(duration, lineSegment, easingFunction, startTimeOffset)" = {animator="playdate.graphics.animator"}
".new(duration, arc, easingFunction, startTimeOffset)" = {animator="playdate.graphics.animator"}
".new(duration, polygon, easingFunction, startTimeOffset)" = {animator="playdate.graphics.animator"}
".new(durations, parts, easingFunctions, startTimeOffset)" = {animator="playdate.graphics.animator"}
":currentValue()" = {""="number|playdate.geometry.point"}
":valueAtTime(time)" = {""="number|playdate.geometry.point"}
":progress()" = {progress="number"}
":reset(duration)" = {}
":ended()" = {""="boolean"}

["playdate.graphics.animation.loop"]
".new(delay, imageTable, shouldLoop)" = {""="playdate.graphics.animation.loop"}
":draw(x, y, flip)" = {}
":image()" = {image="playdate.graphics.image"}
":isValid()" = {""="boolean"}
":setImageTable(imageTable)" = {}

["playdate.graphics.animation.blinker"]
".blinker.new(onDuration, offDuration, loop, cycles, default)" = {""="playdate.graphics.animation.blinker"}
".blinker.stopAll()" = {}
".blinker.updateAll()" = {}
".blinker:remove()" = {}
".blinker:start(onDuration, offDuration, loop, cycles, default)" = {}
".blinker:startLoop()" = {}
".blinker:stop()" = {}
".blinker:update()" = {}

["playdate.graphics.font"]
".font.new(path)" = {""="playdate.graphics.font"}
".font.newFamily(fontPaths)" = {""="playdate.graphics.font[]"} # array of length 3 (regular, bold, italic)
".font:drawText(text, x, y, leadingAdjustment)" = {}
".font:drawTextAligned(text, x, y, alignment, leadingAdjustment)" = {}
".font:getGlyph(character)" = {""="playdate.graphics.image"}
".font:getHeight()" = {pixel_height="integer"}
".font:getLeading()" = {""="integer"}
".font:getTextWidth(text)" = {""="integer"}
".font:getTracking()" = {""="integer"}
".font:setLeading(pixels)" = {}
".font:setTracking(pixels)" = {}

["playdate.graphics.video"]
".new(path)" = {""="playdate.graphics.video"}
":getContext()" = {""="playdate.graphics.image"}
":getFrameCount()" = {""="integer"}
":getFrameRate()" = {""="number"}
":getSize()" = {x="integer", y="integer"}
":renderFrame(number)" = {}
":setContext(image)" = {}
":useScreenContext()" = {}

["playdate.graphics.image"]
".new(width, height, bgcolor)" = {image="playdate.graphics.image"}
".new(path)" = {image="playdate.graphics.image?", error="string?"}
":load(path)" = {success="boolean", error="string?"}
":copy()" = {image="playdate.graphics.image"}
":getSize()" = {width="integer", height="integer"}
":draw(x, y, flip, sourceRect)" = {}
":draw(p, flip, sourceRect)" = {}
":drawAnchored(x, y, ax, ay, flip)" = {}
":drawCentered(x, y, flip)" = {}
":drawIgnoringOffset(x, y, flip)" = {}
":drawIgnoringOffset(p, flip)" = {}
":clear(color)" = {}
":sample(x, y)" = {color="integer"}
":drawRotated(x, y, angle, scale, yscale)" = {}
":rotatedImage(angle, scale, yscale)" = {image="playdate.graphics.image"}
":drawScaled(x, y, scale, yscale)" = {}
":scaledImage(scale, yscale)" = {image="playdate.graphics.image"}
":drawWithTransform(xform, x, y)" = {}
":transformedImage(xform)" = {image="playdate.graphics.image"}
":drawSampled(x, y, width, height, centerx, centery, dxx, dyx, dxy, dyy, dx, dy, z, tiltAngle, tile)" = {}
":setMaskImage(maskImage)" = {}
":getMaskImage()" = {image="playdate.graphics.image"}
":addMask(opaque)" = {}
":removeMask()" = {}
":hasMask()" = {""="boolean"}
":clearMask(opaque)" = {}
":drawTiled(x, y, width, height, flip)" = {}
":drawTiled(rect, flip)" = {}
":drawBlurred(x, y, radius, numPasses, ditherType, flip, xPhase, yPhase)" = {}
":drawFaded(x, y, alpha, ditherType)" = {}
":setInverted(flag)" = {}
":invertedImage()" = {image="playdate.graphics.image"}
":blendWithImage(image, alpha, ditherType)" = {image="playdate.graphics.image"}
":blurredImage(radius, numPasses, ditherType, padEdges, xPhase, yPhase)" = {image="playdate.graphics.image"}
":fadedImage(alpha, ditherType)" = {image="playdate.graphics.image"}
":vcrPauseFilterImage()" = {image="playdate.graphics.image"}

["playdate.graphics.imagetable"]
".new(path)" = {""="playdate.graphics.imagetable"}
".new(count, cellsWide, cellSize)" = {""="playdate.graphics.imagetable"}
":drawImage(n, x, y, flip)" = {}
":getImage(n)" = {image="playdate.graphics.image"}
":getImage(x, y)" = {image="playdate.graphics.image"}
":setImage(n, image)" = {}
":load(path)" = {success="boolean", error="string?"}
":getLength()" = {""="integer"}
":getSize()" = {cellsWide="integer", cellsHigh="integer"}
":__index(n)" = {}

["playdate.graphics.sprite"]
".addDirtyRect(x, y, width, height)" = {}
".addEmptyCollisionSprite(r)" = {}
".addEmptyCollisionSprite(x, y, w, h)" = {}
".addSprite(sprite)" = {}
".addWallSprites(tilemap, emptyIDs, xOffset, yOffset)" = {}
".allOverlappingSprites()" = {""="playdate.graphics.sprite[][]"} # TODO: Double check whether this is correct typing.
".clearClipRectsInRange(startz, endz)" = {}
".getAllSprites()" = {""="playdate.graphics.sprite[]"}
".getAlwaysRedraw()" = {""="boolean"}
".new(image_or_tilemap)" = {""="playdate.graphics.sprite"}
".performOnAllSprites(f)" = {}
".querySpriteInfoAlongLine(lineSegment)" = {""="CollisionInfo[]"}
".querySpriteInfoAlongLine(x1, y1, x2, y2)" = {""="CollisionInfo[]"}
".querySpritesAlongLine(lineSegment)" = {""="playdate.graphics.sprite[]"}
".querySpritesAlongLine(x1, y1, x2, y2)" = {""="playdate.graphics.sprite[]"}
".querySpritesAtPoint(p)" = {""="playdate.graphics.sprite[]"}
".querySpritesAtPoint(x, y)" = {""="playdate.graphics.sprite[]"}
".querySpritesInRect(rect)" = {""="playdate.graphics.sprite[]"}
".querySpritesInRect(x, y, width, height)" = {""="playdate.graphics.sprite[]"}
".redrawBackground()" = {}
".removeAll()" = {}
".removeSprite(sprite)" = {}
".removeSprites(spriteArray)" = {}
".setAlwaysRedraw(flag)" = {}
".setBackgroundDrawingCallback(drawCallback)" = {}
".setClipRectsInRange(rect, startz, endz)" = {}
".setClipRectsInRange(x, y, width, height, startz, endz)" = {}
".spriteCount()" = {""="integer"}
".spriteWithText(text, maxWidth, maxHeight, backgroundColor, leadingAdjustment, truncationString, alignment, font)" = {""="playdate.graphics.sprite"}
".update()" = {}
":add()" = {}
":alphaCollision(anotherSprite)" = {""="boolean"}
":checkCollisions(point)" = {actualX="integer", actualY="integer", collisions="table|CollisionData[]", length="integer"}
":checkCollisions(x, y)" = {actualX="integer", actualY="integer", collisions="table|CollisionData[]", length="integer"}
":clearClipRect()" = {}
":clearCollideRect()" = {}
":clearStencil()" = {}
":collisionResponse(other)" = {"collision_type"="integer"} # TODO: CollisionType
":collisionsEnabled()" = {""="boolean"}
":copy()" = {""="playdate.graphics.sprite"}
":draw(x, y, width, height)" = {}
":getBounds()" = {x="integer", y="integer", width="integer", height="integer"}
":getBoundsRect()" = {r="playdate.geometry.rect"}
":getCenter()" = {x="number", y="number"} # each 0.0 to 1.0
":getCenterPoint()" = {""="playdate.geometry.point"}
":getCollideBounds()" = {x="integer", y="integer", width="integer", height="integer"}
":getCollideRect()" = {r="playdate.geometry.rect"}
":getCollidesWithGroupsMask()" = {bitmask="integer"}
":getGroupMask()" = {bitmask="integer"}
":getImage()" = {""="playdate.graphics.image"}
":getImageFlip()" = {flip="integer"} # TODO: Flip
":getPosition()" = {x="integer", y="integer"}
":getRotation()" = {degrees="number"}
":getScale()" = {xScale="integer", yScale="integer"}
":getSize()" = {width="integer", height="integer"}
":getTag()" = {tag="integer"}
":getZIndex()" = {""="integer"}
":isOpaque()" = {""="boolean"}
":isVisible()" = {""="boolean"}
":markDirty()" = {}
":moveBy(x, y)" = {}
":moveTo(x, y)" = {}
":moveWithCollisions(goalPoint)" = {actualX="integer", actualY="integer", collisions="table|CollisionData[]", length="integer"}
":moveWithCollisions(goalX, goalY)" = {actualX="integer", actualY="integer", collisions="table|CollisionData[]", length="integer"}
":overlappingSprites()" = {""="playdate.graphics.sprite[]"}
":remove()" = {}
":removeAnimator()" = {}
":resetCollidesWithGroupsMask()" = {}
":resetGroupMask()" = {}
":setAnimator(animator, moveWithCollisions, removeOnCollision)" = {}
":setBounds(rect)" = {}
":setBounds(x, y, width, height)" = {}
":setCenter(x, y)" = {}
":setClipRect(rect)" = {}
":setClipRect(x, y, width, height)" = {}
":setCollideRect(rect)" = {}
":setCollideRect(x, y, width, height)" = {}
":setCollidesWithGroups(groups)" = {}
":setCollidesWithGroupsMask(mask)" = {}
":setCollisionsEnabled(flag)" = {}
":setGroupMask(mask)" = {}
":setGroups(groups)" = {}
":setIgnoresDrawOffset(flag)" = {}
":setImage(image, flip, scale, yscale)" = {}
":setImageDrawMode(mode)" = {}
":setImageFlip(flip, flipCollideRect)" = {}
":setOpaque(flag)" = {}
":setRedrawsOnImageChange(flag)" = {}
":setRotation(angle, scale, yScale)" = {}
":setScale(scale, yScale)" = {}
":setSize(width, height)" = {}
":setStencilImage(stencil, tile)" = {}
":setStencilPattern(level, ditherType)" = {}
":setStencilPattern(pattern)" = {}
":setTag(tag)" = {}
":setTilemap(tilemap)" = {}
":setUpdatesEnabled(flag)" = {}
":setVisible(flag)" = {}
":setZIndex(z)" = {}
":update()" = {}
":updatesEnabled()" = {""="boolean"}

["playdate.graphics.tilemap"]
".tilemap.new()" = {""="playdate.graphics.tilemap"}
".tilemap:draw(x, y, sourceRect)" = {}
".tilemap:drawIgnoringOffset(x, y, sourceRect)" = {}
".tilemap:getCollisionRects(emptyIDs)" = {rects="playdate.geometry.rect[]"}
".tilemap:getTileAtPosition(x, y)" = {index="integer"}
".tilemap:getTiles()" = {data="integer[]", width="integer"}
".tilemap:getSize()" = {width="integer", height="integer"}
".tilemap:getPixelSize()" = {width="integer", height="integer"}
".tilemap:getTileSize()" = {width="integer", height="integer"}
".tilemap:setImageTable(table)" = {}
".tilemap:setTileAtPosition(x, y, index)" = {}
".tilemap:setTiles(data, width)" = {}
".tilemap:setSize(width, height)" = {}

["playdate.keyboard"]
".show(text)" = {}
".hide()" = {}
".setCapitalizationBehavior(behavior)" = {}
".left()" = {}
".width()" = {}
".isVisible()" = {}
"keyboardDidHideCallback()" = {}
"keyboardWillHideCallback()" = {}
"keyboardAnimatingCallback()" = {}
"textChangedCallback(ok)" = {}

["playdate.math.lerp"]
".lerp(min, max, t)" = {""="number"}

["playdate.menu"]
":addMenuItem(title, callback)" = {}
":addCheckmarkMenuItem(title, initialValue, callback)" = {}
":addOptionsMenuItem(title, options, initalValue, callback)" = {}
":getMenuItems()" = {"menuItems"="playdate.menu.item[]"}
":removeMenuItem(menuItem)" = {}
":removeAllMenuItems()" = {}

["playdate.menu.item"]
":setCallback(callback)" = {}
":setTitle(newTitle)" = {}
":getTitle()" = {title="string"}
":setValue(newValue)" = {}
":getValue()" = {value="integer|boolean|string"}

["playdate.pathfinder"]

["playdate.pathfinder.graph"]
".new(nodeCount, coordinates)" = {""="playdate.pathfinder.graph"}
".new2DGrid(width, height, allowDiagonals, includedNodes)" = {""="playdate.pathfinder.graph"}
":addConnectionToNodeWithID(fromNodeID, toNodeID, weight, addReciprocalConnection)" = {}
":addConnections(connections)" = {}
":addNewNode(id, x, y, connectedNodes, weights, addReciprocalConnections)" = {}
":addNewNodes(count)" = {}
":addNode(node, connectedNodes, weights, addReciprocalConnections)" = {}
":addNodes(nodes)" = {}
":allNodes()" = {nodes="playdate.pathfinder.node[]"}
":findPath(startNode, goalNode, heuristicFunction, findPathToGoalAdjacentNodes)" = {nodes="playdate.pathfinder.node[]"}
":findPathWithIDs(startNodeID, goalNodeID, heuristicFunction, findPathToGoalAdjacentNodes)" = {"node_ids"="integer[]"}
":nodeWithID(id)" = {node="playdate.pathfinder.node?"}
":nodeWithXY(x, y)" = {node="playdate.pathfinder.node?"}
":removeAllConnections()" = {}
":removeAllConnectionsFromNodeWithID(id, removeIncoming)" = {}
":removeNode(node)" = {}
":removeNodeWithID(id)" = {}
":removeNodeWithXY(x, y)" = {}
":setXYForNodeWithID(id, x, y)" = {}

["playdate.pathfinder.node"]
".node:addConnection(node, weight, addReciprocalConnection)" = {}
".node:addConnections(nodes, weights, addReciprocalConnections)" = {}
".node:addConnectionToNodeWithXY(x, y, weight, addReciprocalConnection)" = {}
".node:connectedNodes()" = {nodes="playdate.pathfinder.node[]"}
".node:removeConnection(node, removeReciprocal)" = {}
".node:removeAllConnections(removeIncoming)" = {}
".node:setXY(x, y)" = {}

["playdate.simulator"]
".getURL(url)" = {url_contents="string"} # TODO: check if it returns nil on failure.
".exit()" = {}
".writeToFile(image, path)" = {} # TODO: check it returns succes/failure

["playdate.sound"]
".addEffect(effect)" = {}
".getCurrentTime()" = {seconds="number"}
".getHeadphoneState(changeCallback)" = {headphone="boolean", mic="boolean?"}
".getSampleRate()" = {sampleRate="integer"} # 44100.0
".playingSources()" = {sources="playdate.sound.source[]"} # parent class to fileplayer,sampleplayer,synth,instrumnet
".removeEffect(effect)" = {}
".resetTime()" = {}
".setOutputsActive(headphones, speaker)" = {}

["playdate.sound.sampleplayer"]
".new(path)" = {""="playdate.sound.sampleplayer"}
".new(sample)" = {""="playdate.sound.sampleplayer"}
":copy()" = {""="playdate.sound.sampleplayer"}
":play(repeatCount, rate)" = {}
":playAt(when, vol, rightvol, rate)" = {}
":setVolume(left, right)" = {}
":getVolume()" = {left_or_mono="number", right="number?"}
":setLoopCallback(callback, arg)" = {}
":setPlayRange(start, _end)" = {}
":setPaused(flag)" = {}
":isPlaying()" = {""="boolean"}
":stop()" = {}
":setFinishCallback(func, arg)" = {}
":setSample(sample)" = {}
":getSample()" = {""="playdate.sound.sample"}
":getLength()" = {seconds="number"}
":setRate(rate)" = {}
":getRate()" = {rate="number"}
":setRateMod(signal)" = {}
":setOffset(seconds)" = {}
":getOffset()" = {seconds="number"}

["playdate.sound.fileplayer"]
".new(buffersize)" = {""="playdate.sound.fileplayer"}
".new(path, buffersize)" = {""="playdate.sound.fileplayer"}
":didUnderrun()" = {""="boolean"}
":getLength()" = {"seconds"="number"}
":getOffset()" = {seconds="number"}
":getRate()" = {"rate"="number"}
":getVolume()" = {left_or_mono="number", right="number?"}
":isPlaying()" = {""="boolean"}
":load(path)" = {} # TODO: Check if returns success/failure
":pause()" = {}
":play(repeatCount)" = {success="boolean", error="string?"}
":setBufferSize(seconds)" = {}
":setFinishCallback(func, arg)" = {}
":setLoopCallback(callback, arg)" = {}
":setLoopRange(start, _end, loopCallback, arg)" = {}
":setOffset(seconds)" = {}
":setRate(rate)" = {}
":setRateMod(signal)" = {}
":setStopOnUnderrun(flag)" = {}
":setVolume(left, right, fadeSeconds, fadeCallback, arg)" = {}
":stop()" = {}

["playdate.sound.sample"]
".new(path)" = {""="playdate.sound.sample"}
".new(seconds, format)" = {""="playdate.sound.sample"} # TODO: This is incorrectly formatted in source docs.
":getFormat()" = {""="integer"} # TODO: SoundFormat
":getLength()" = {"sample_seconds"="number", "buffer_size_seconds"="number"}
":getSampleRate()" = {""="integer"} # ex: 44100/22050
":getSubsample(startOffset, endOffset)" = {""="playdate.sound.sample"}
":load(path)" = {""="boolean"} # TODO: Validate what happens when sample correctly loads. (boolean?) nil=fail?
":play(repeatCount, rate)" = {}
":playAt(when, vol, rightvol, rate)" = {}
":save(filename)" = {} # TODO: Validate what happens if this fails

["playdate.sound.channel"]
".new()" = {""="playdate.sound.channel"}
":remove()" = {}
":addEffect(effect)" = {}
":removeEffect(effect)" = {}
":addSource(source)" = {}
":removeSource(source)" = {}
":setVolume(volume)" = {}
":getVolume()" = {"volume"="number"}
":setPan(pan)" = {"pan"="number"}
":setPanMod(signal)" = {}
":setVolumeMod(signal)" = {}

["playdate.sound.source"] # parent class to fileplayer,sampleplayer,synth,instrumnet

["playdate.sound.synth"]
".new(sample, sustainStart, sustainEnd)" = {""="playdate.sound.synth"}
".new(waveform)" = {""="playdate.sound.synth"}
":copy()" = {""="playdate.sound.synth"}
":getEnvelope()" = {""="playdate.sound.envelope"}
":getVolume()" = {left_or_mono="number", right="number?"}
":isPlaying()" = {""="boolean"}
":noteOff()" = {}
":playMIDINote(note, volume, length, when)" = {success="boolean"}
":playNote(pitch, volume, length, when)" = {success="boolean"}
":setADSR(attack, decay, sustain, release, curvature)" = {}
":setAmplitudeMod(signal)" = {}
":setAttack(time)" = {}
":setDecay(time)" = {}
":setEnvelopeCurvature(amount)" = {}
":setFinishCallback(_function)" = {}
":setFrequencyMod(signal)" = {}
":setLegato(flag)" = {}
":setParameter(parameter, value)" = {}
":setParameterMod(parameter, signal)" = {}
":setRelease(time)" = {}
":setSustain(level)" = {}
":setVolume(left, right)" = {}
":setWaveform(waveform)" = {}
":stop()" = {}

["playdate.sound.signal"]
".signal:setOffset(offset)" = {}
".signal:setScale(scale)" = {}

["playdate.sound.lfo"]
".new(type)" = {""="playdate.sound.lfo"}
":setArpeggio(note1, ...)" = {}
":setCenter(center)" = {}
":setDelay(holdoff, ramp)" = {}
":setDepth(depth)" = {}
":setGlobal(flag)" = {}
":setPhase(phase)" = {}
":setRate(rate)" = {}
":setRetrigger(flag)" = {}
":setType(type)" = {}

["playdate.sound.envelope"]
".new(attack, decay, sustain, release)" = {""="playdate.sound.envelope"}
":setAttack(attack)" = {}
":setDecay(decay)" = {}
":setSustain(sustain)" = {}
":setRelease(release)" = {}
":setCurvature(amount)" = {}
":setVelocitySensitivity(amount)" = {}
":setRateScaling(scaling, start, _end)" = {}
":setScale(scale)" = {}
":setOffset(offset)" = {}
":setLegato(flag)" = {}
":setRetrigger(flag)" = {}
":trigger(velocity, length)" = {}
":setGlobal(flag)" = {}

["playdate.sound.effect"]

["playdate.sound.bitcrusher"]
".new()" = {""="playdate.sound.bitcrusher"}
":setMix(level)" = {}
":setMixMod(signal)" = {}
":setAmount(amt)" = {}
":setAmountMod(signal)" = {}
":setUndersampling(amt)" = {}
":setUndersamplingMod(signal)" = {}

["playdate.sound.ringmod"]
".new()" = {""="playdate.sound.ringmod"}
":setFrequency(f)" = {}
":setFrequencyMod(signal)" = {}
":setMix(level)" = {}
":setMixMod(signal)" = {}

["playdate.sound.onepolefilter"]
".new()" = {""="playdate.sound.onepolefilter"}
":setMix(level)" = {}
":setMixMod(signal)" = {}
":setParameter(p)" = {}
":setParameterMod(m)" = {}

["playdate.sound.twopolefilter"]
".new(type)" = {""="playdate.sound.twopolefilter"}
":setMix(level)" = {}
":setMixMod(signal)" = {}
":setFrequency(f)" = {}
":setFrequencyMod(signal)" = {}
":setResonance(r)" = {}
":setResonanceMod(signal)" = {}
":setGain(g)" = {}
":setType(type)" = {}

["playdate.sound.overdrive"]
".new()" = {""="playdate.sound.overdrive"}
":setGain(level)" = {}
":setLimit(level)" = {}
":setLimitMod(signal)" = {}
":setMix(level)" = {}
":setMixMod(signal)" = {}
":setOffset(level)" = {}
":setOffsetMod(signal)" = {}

["playdate.sound.delayline"]
".new(length)" = {""="playdate.sound.delayline"}
":addTap(delay)" = {}
":setFeedback(level)" = {}
":setMix(level)" = {}
":setMixMod(signal)" = {}

["playdate.sound.delaylinetap"]
":getVolume()" = {volume="number"}
":setDelay(time)" = {}
":setDelayMod(signal)" = {}
":setFlipChannels(flag)" = {}
":setVolume(level)" = {}

["playdate.sound.sequence"]
".new(midi_path)" = {""="playdate.sound.sequence"}
":play(finishCallback)" = {}
":stop()" = {}
":isPlaying()" = {""="boolean"}
":getLength()" = {steps="number"}
":goToStep(step, play)" = {}
":getCurrentStep()" = {step="number"}
":setTempo(stepsPerSecond)" = {}
":getTempo()" = {stepsPerSecond="number"}
":setLoops(startStep, endStep, loopCount)" = {}
":setLoops(loopCount)" = {}
":getTrackCount()" = {tracks="integer"}
":addTrack(track)" = {}
":setTrackAtIndex(n, track)" = {}
":getTrackAtIndex(n)" = {""="playdate.sound.track"}
":allNotesOff()" = {}

["playdate.sound.track"]
".new()" = {""="playdate.sound.track"}
":addControlSignal(s)" = {}
":addNote(step, note, length, velocity)" = {}
":addNote(table)" = {}
":clearNotes()" = {}
":getControlSignals()" = {""="playdate.sound.controlsignal[]"}
":getInstrument()" = {""="playdate.sound.instrument"}
":getLength()" = {steps="integer"}
":getNotes(step, endstep)" = {notes="SoundTrackNoteOut[]"}
":getNotesActive()" = {active_notes="integer"}
":getPolyphony()" = {max_active_notes="integer"}
":removeNote(step, note)" = {}
":setInstrument(inst)" = {}
":setMuted(flag)" = {}
":setNotes(list)" = {}

["playdate.sound.instrument"]
".new(synth)" = {""="playdate.sound.instrument"}
":addVoice(v, note, rangeend, transpose)" = {}
":allNotesOff()" = {}
":getVolume()" = {left_or_mono="number", right="number?"}
":noteOff(note, when)" = {}
":playMIDINote(note, vel, length, when)" = {}
":playNote(frequency, vel, length, when)" = {}
":setTranspose(halfsteps)" = {}
":setVolume(left, right)" = {}

["playdate.sound.controlsignal"]
".new()" = {""="playdate.sound.controlsignal"}
":addEvent(step, value, interpolate)" = {}
":addEvent(event)" = {}
":clearEvents()" = {}
":setControllerType(number)" = {}
":getControllerType()" = {controller_type="integer"}

["playdate.sound.micinput"]
".getLevel()" = {""="number"} # 0.0-1.0
".getSource()" = {"headset_or_device"="string"} # "headset" or "device"
".recordToSample(buffer, completionCallback)" = {}
".startListening()" = {}
".stopListening()" = {}
".stopRecording()" = {}

["playdate.string"]
".UUID(length)" = {"uppercase_letters"="string"}
".trimWhitespace(string)" = {""="string"}
".trimLeadingWhitespace(string)" = {""="string"}
".trimTrailingWhitespace(string)" = {""="string"}

["playdate.timer"]
".allTimers()" = {}
".keyRepeatTimer(callback, ...)" = {}
".keyRepeatTimerWithDelay(delayAfterInitialFiring, delayAfterSecondFiring, callback, ...)" = {}
".new(duration, callback, ...)" = {""="playdate.timer"}
".new(duration, startValue, endValue, easingFunction)" = {}
".performAfterDelay(delay, callback, ...)" = {}
".updateTimers()" = {}
":pause()" = {}
":remove()" = {}
":reset()" = {}
":start()" = {}

["playdate.frameTimer"]
".allTimers()" = {""="playdate.frameTimer[]"}
".new(duration, callback, ...)" = {""="playdate.frameTimer"}
".new(duration, startValue, endValue, easingFunction)" = {""="playdate.frameTimer"}
".performAfterDelay(delay, callback, ...)" = {}
".updateTimers()" = {}
":pause()" = {}
":remove()" = {}
":reset()" = {}
":start()" = {}

["playdate.ui"]

["playdate.ui.crankIndicator"]
".update()" = {}
".start()" = {}

["playdate.ui.gridview"]
".new(cellWidth, cellHeight)" = {""="playdate.ui.gridview"}
":addHorizontalDividerAbove(section, row)" = {}
":drawCell(section, row, column, selected, x, y, width, height)" = {}
":drawHorizontalDivider(x, y, width, height)" = {}
":drawInRect(x, y, width, height)" = {}
":drawSectionHeader(section, x, y, width, height)" = {}
":getCellBounds(section, row, column, gridWidth)" = {x="integer", y="integer", width="integer", height="integer"}
":getHorizontalDividerHeight()" = {height="integer"}
":getNumberOfColumns()" = {columns="integer"}
":getNumberOfRowsInSection(section)" = {rows="integer"}
":getNumberOfSections()" = {sections="integer"}
":getScrollPosition()" = {x="integer", y="integer"}
":getSectionHeaderHeight()" = {""="integer"}
":getSelectedRow()" = {row="integer"}
":getSelection()" = {section="integer", row="integer", column="integer"}
":removeHorizontalDividers()" = {}
":scrollCellToCenter(section, row, column, animated)" = {}
":scrollToCell(section, row, column, animated)" = {}
":scrollToRow(row, animated)" = {}
":scrollToTop(animated)" = {}
":selectNextColumn(wrapSelection, scrollToSelection, animate)" = {}
":selectNextRow(wrapSelection, scrollToSelection, animate)" = {}
":selectPreviousColumn(wrapSelection, scrollToSelection, animate)" = {}
":selectPreviousRow(wrapSelection, scrollToSelection, animate)" = {}
":setCellPadding(left, right, top, bottom)" = {}
":setCellSize(cellWidth, cellHeight)" = {}
":setContentInset(left, right, top, bottom)" = {}
":setHorizontalDividerHeight(height)" = {}
":setNumberOfColumns(num)" = {}
":setNumberOfRows(...)" = {}
":setNumberOfRowsInSection(section, num)" = {}
":setNumberOfSections(num)" = {}
":setScrollDuration(ms)" = {}
":setScrollPosition(x, y, animated)" = {}
":setSectionHeaderHeight(height)" = {}
":setSectionHeaderPadding(left, right, top, bottom)" = {}
":setSelectedRow(row)" = {}
":setSelection(section, row, column)" = {}

["table"]
".indexOfElement(table, element)" = {index="integer?"}
".getsize(table)" = {arrayCount="integer", hashCount="integer"}
".create(arrayCount, hashCount)" = {""="table"}
".shallowcopy(source, destination)" = {""="table"} # TODO: Check if destination is returned if provided
".deepcopy(source)" = {""="table"}

["global"] # TODO: Make sure this gets special handling
"print(...)" = {}
"printTable(table)" = {}
"where()" = {traceback="string"}
"sample(name, _function)" = {}
