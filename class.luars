mod json;

mod playdate;
obj playdate._metadata {
    name: string,
    author: string,
    description: string,
    bundleID: string,
    version: string,
    buildNumber: integer,
    pdxversion: integer, // 2000,
    imagePath?: string,
    launchSoundPath?: string,
    contentWarning?: string,
    contentWarning2?: string,
    ...: string,
};
obj playdate._PowerStatus {
    charging: boolean;
    USB: boolean;
    screws: boolean;
};
obj playdate._systeminfo {       // Undocumented. Observed values:
    buildtime: string,          // "20230706_121810;
    commit: string,             // "f5a85fc69f11-2.0.1-release.156292-buildbot;
    pdxcompatversion: integer;  // 10000
    pdxversion: integer,        // 20000
};
obj playdate._DateTime { // returned by playdate.getTime() and playdate.getGMTTime()
    year: integer,          // 4-digit year
    month: integer,         // month of the year 1-12
    day: integer,           // day of the month 1-31
    weekday: integer,       // day of the week, where 1 is Monday and 7 is Sunday
    hour: integer,          // hour 0-23
    minute: integer,        // minute 0-59
    second: integer,        // second 0-59 (or 60 on a leap second)
    millisecond: integer,   // millisecond 0-999
};
obj playdate._SystemStats { // Returned from playdate.getStats(); Note the leding spaces on keys. Device only.
    " kernel": number,
    " game": number,
    " audio": number,
}
let playdate.argv:Â string[];
let playdate.isSimulator: boolean;
let playdate.metadata: playdate._metadata;
let playdate.systeminfo: playdate._systeminfo;

mod playdate.datastore;

mod playdate.display;

mod playdate.easingFunctions;

mod playdate.frameTimer;
obj playdate.frameTimer {
    delay: integer,
    discardOnCompletion: boolean,
    duration: integer,
    frame: integer,
    repeats: boolean,
    reverses: boolean,
    timerEndedArgs: any,
};

mod playdate.inputHandlers;
obj playdate.inputHandlers._InputHandler {
    AButtonDown?: fun(),
    AButtonHeld?: fun(),
    AButtonUp?: fun(),
    BButtonDown?: fun(),
    BButtonHeld?: fun(),
    BButtonUp?: fun(),
    downButtonDown?: fun(),
    downButtonUp?: fun(),
    leftButtonDown?: fun(),
    leftButtonUp?: fun(),
    rightButtonDown?: fun(),
    rightButtonUp?: fun(),
    upButtonDown?: fun(),
    upButtonUp?: fun(),
    cranked?: fun(change:number, acceleratedChange:number),
};

mod playdate.file;
obj playdate.file._ModTime {// second level accuracy time.  Used by playdate.file.modtime
    year: integer,          // 4-digit year
    month: integer,         // month of the year 1-12
    day: integer,           // day of the month 1-31
    hour: integer,          // hour 0-23
    minute: integer,        // minute 0-59
    second: integer,        // second 0-59 (or 60 on a leap second)
}

mod playdate.file.file;
obj playdate.file.file;

mod playdate.geometry;
con playdate.geometry.kUnflipped: integer = 0;
con playdate.geometry.kFlippedX: integer = 1;
con playdate.geometry.kFlippedY: integer = 2;
con playdate.geometry.kFlippedXY: integer = 3;
cat playdate.geometry._FlipType: integer (
    | playdate.geometry.kUnflipped
    | playdate.geometry.kFlippedX
    | playdate.geometry.kFlippedY
    | playdate.geometry.kFlippedXY
);
cat playdate.geometry._FlipTypeStr: string (
    | "flipX"
    | "flipY"
    | "filpXY"
)

mod playdate.geometry.affineTransform;
obj playdate.geometry.affineTransform;

mod playdate.geometry.arc;
obj playdate.geometry.arc {
    x: integer,
    y: integer,
    radius: integer,
    startAngle: number,
    endAngle: number,
    direction: boolean,
};

mod playdate.geometry.lineSegment;
obj playdate.geometry.lineSegment {
    x1: integer,
    y1: integer,
    x2: integer,
    y2: integer,
};

mod playdate.geometry.point;
obj playdate.geometry.point {
    x: number;
    y: number;
};

mod playdate.geometry.polygon;
obj playdate.geometry.polygon;

mod playdate.geometry.rect;
obj playdate.geometry.rect {
    x: number,
    y: number,
    width: number,
    height: number,
    top: number,
    bottom: number,
    left: number,
    right: number,
    size: playdate.geometry.size,
}

mod playdate.geometry.size;
obj playdate.geometry.size {
    width: number,
    height: number,
};

mod playdate.geometry.vector2D;
obj playdate.geometry.vector2D {
    dx: number,
    dy: number,
};

mod playdate.graphics;

mod playdate.graphics.animation;

mod playdate.graphics.animation.loop;
obj playdate.graphics.animation.loop {
    delay: number,
    startFrame: integer,
    endFrame: integer,
    frame: integer,
    step: integer,
    shouldLoop: boolean,
    paused: boolean,
};

mod playdate.graphics.animation.blinker;
obj playdate.graphics.animation.blinker {
    onDuration: integer,
    offDuration: integer,
    loop: boolean,
    cycles: integer,
    default: boolean,
    counter: integer,
    on: boolean,
    running: boolean,
};

mod playdate.graphics.animator;
obj playdate.graphics.animator {
    repeatCount: integer,
    reverses: integer,
    easingAmplitude: number,
    easingPeriod: number,
    s?: number,
    a?: number,
    p?: number,
};

mod playdate.graphics.font;
con playdate.graphics.font.kLanguageEnglish: integer = 0;
con playdate.graphics.font.kLanguageJapanese: integer = 1;
con playdate.graphics.font.kVariantNormal: integer = 0;
con playdate.graphics.font.kVariantBold: integer = 1;
con playdate.graphics.font.kVariantItalic: integer = 2;
cat playdate.graphics.font._FontVariant: integer (
    | playdate.graphics.font.kVariantNormal
    | playdate.graphics.font.kVariantBold
    | playdate.graphics.font.kVariantItalic
);
cat playdate.graphics.font.FontVariantStr: string (
    | "normal"
    | "bold"
    | "italic"
);
cat playdate.graphics.font._Language: integer (
    | playdate.graphics.font.kLanguageEnglish
    | playdate.graphics.font.kLanguageJapanese
);
cat playdate.graphics.font._LanguageStr: string (
    | "en"
    | "jp"
);
obj playdate.graphics.font;

mod playdate.graphics.image;
obj playdate.graphics.image {
    x: integer,
    y: integer,
    width: integer,
    height: integer,
};

mod playdate.graphics.imagetable;
obj playdate.graphics.imagetable;

mod playdate.graphics.nineSlice;
obj playdate.graphics.nineSlice {
    innerRect: playdate.geometry.rect,
    minWidth: integer,
    minHeight: integer,
};

mod playdate.graphics.sprite;
con playdate.graphics.sprite.kCollisionTypeSlide = 0;
con playdate.graphics.sprite.kCollisionTypeFreeze = 1;
con playdate.graphics.sprite.kCollisionTypeOverlap = 2
con playdate.graphics.sprite.kCollisionTypeBounce = 3
cat playdate.graphics.sprite._CollisionType: integer (
    | playdate.graphics.sprite.kCollisionTypeSlide
    | playdate.graphics.sprite.kCollisionTypeFreeze
    | playdate.graphics.sprite.kCollisionTypeOverlap
    | playdate.graphics.sprite.kCollisionTypeBounce
);
cat playdate.graphics.sprite._collisionResponse (
    | nil
    | playdate.graphics.sprite._CollisionType
    | fun(self: playdate.graphics.sprite, other: playdate.graphics.sprite) -> playdate.graphics.sprite._CollisionType
);
obj playdate.graphics.sprite {
    x: integer,
    y: integer,
    width: integer,
    height: integer,
    collisionResponse?: playdate.graphics.sprite._collisionResponse,
    update?: fun()->nil,
};
obj playdate.graphics.sprite._CollisionData { // returned from sprite:moveWithCollisions and sprite:checkCollisions
    sprite: playdate.graphics.sprite,
    other: playdate.graphics.sprite,
    type: playdate.graphics.sprite._CollisionType,
    overlaps: boolean,
    ti: number, // 0.0-1.0
    move: playdate.geometry.vector2D,
    normal: playdate.geometry.vector2D,
    touch: playdate.geometry.point,
    spriteRect: playdate.geometry.rect,
    otherRect: playdate.geometry.rect,
    bounce?: playdate.geometry.point,
    slide?: playdate.geometry.point,
};
obj playdate.graphics.sprite._CollisionInfo { // returned from playdate.graphics.sprite.querySpriteInfoAlongLine
    sprite: playdate.graphics.sprite,
    entryPoint: playdate.geometry.point,
    exitPoint: playdate.geometry.point,
    t1: number,
    t2: number,
};

mod playdate.graphics.tilemap;
obj playdate.graphics.tilemap;

mod playdate.graphics.video;
obj playdate.graphics.video;

mod playdate.inputHandlers;

mod playdate.keyboard;
obj playdate.keyboard {
    text: string,
};

mod playdate.math;

mod playdate.menu;

mod playdate.menu.item;
obj playdate.menu.item {
    title: string,
    value: (integer|boolean|string),
};

mod playdate.pathfinder;

mod playdate.pathfinder.graph;
obj playdate.pathfinder.graph;

mod playdate.pathfinder.node;
obj playdate.pathfinder.node {
    x: integer,
    y: integer,
    id: integer,
};

mod playdate.simulator;

mod playdate.sound;

mod playdate.sound.effect;
obj playdate.sound.effect;

mod playdate.sound.bitcrusher;
obj playdate.sound.bitcrusher: playdate.sound.effect;

mod playdate.sound.channel;
obj playdate.sound.channel;

mod playdate.sound.controlsignal;
obj playdate.sound.controlsignal._ControlSignalEvent {
    step: integer,
    value: number,
    interpolate?: boolean,
};
obj playdate.sound.controlsignal: playdate.sound.signal {
    events: playdate.sound.controlsignal._ControlSignalEvent;
};

mod playdate.sound.delayline;
obj playdate.sound.delayline: playdate.sound.effect;

mod playdate.sound.delaylinetap;
obj playdate.sound.delaylinetap: playdate.sound.source;

mod playdate.sound.effect;
obj playdate.sound.effect;

mod playdate.sound.envelope;
obj playdate.sound.envelope: playdate.sound.signal;

mod playdate.sound.fileplayer;
obj playdate.sound.fileplayer: playdate.sound.source;

mod playdate.sound.instrument;
obj playdate.sound.instrument: playdate.sound.source;

mod playdate.sound.lfo;
obj playdate.sound.lfo: playdate.sound.signal;

mod playdate.sound.onepolefilter;
obj playdate.sound.onepolefilter: playdate.sound.effect;

mod playdate.sound.overdrive;
obj playdate.sound.overdrive: playdate.sound.effect;

mod playdate.sound.ringmod;
obj playdate.sound.ringmod: playdate.sound.effect;

mod playdate.sound.sample;
obj playdate.sound.sample;

mod playdate.sound.sampleplayer;
obj playdate.sound.sampleplayer: playdate.sound.source;

mod playdate.sound.sequence;
obj playdate.sound.sequence;

mod playdate.sound.signal;
obj playdate.sound.signal;

mod playdate.sound.source;
obj playdate.sound.source;

mod playdate.sound.synth;
obj playdate.sound.synth: playdate.sound.source;

mod playdate.sound.track;
obj playdate.sound.track;
obj playdate.sound.track._SoundTrackNoteIn { // This can be used for playdate.sound.track:addNote
    step: integer,
    note: number|string, // midi note number or note name like "Db3
    length: integer,
    velocity: number,
}
obj playdate.sound.track._SoundTrackNote { // This is what comes back from playdate.sound.track:getNote
    step: integer,
    note: number,
    length: integer,
    velocity: number,
};

mod playdate.sound.twopolefilter;
obj playdate.sound.twopolefilter: playdate.sound.effect;

mod playdate.sound.micinput;

mod playdate.string;

mod playdate.timer;
obj playdate.timer {
    currentTime: integer, // read-only
    delay: integer,
    discardOnCompletion: boolean,
    duration: integer,
    timeLeft: integer, // read-only
    repeats: boolean,
    reverses: boolean,
    timerEndedArgs: any[],
};

mod playdate.ui;

mod playdate.ui.crankIndicator;
let playdate.ui.crankIndicator.clockwise: boolean;

mod playdate.ui.gridview;
obj playdate.ui.gridview {
    needsDisplay:boolean, // read-only
    backgroundImage: (playdate.graphics.image|playdate.graphics.nineSlice),
    isScrolling:boolean, // read-only
    scrollEasingFunction:fun(t:number, b:number, c:number, d:number, a?:number, p?:number): number,
    easingAmplitude?: number,
    easingPeriod?: number,
    changeRowOnColumnWrap: boolean,
    scrollCellsToCenter: boolean,
};

mod table;
