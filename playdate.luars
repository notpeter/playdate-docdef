mod json;
mod playdate.datastore;
mod playdate.display;
mod playdate.easingFunctions;
mod playdate.file.file;
mod playdate.file;
mod playdate.frameTimer;
mod playdate.geometry.affineTransform;
mod playdate.geometry.arc;
mod playdate.geometry.lineSegment;
mod playdate.geometry.point;
mod playdate.geometry.polygon;
mod playdate.geometry.rect;
mod playdate.geometry.size;
mod playdate.geometry.vector2D;
mod playdate.geometry;
mod playdate.graphics.animation.blinker;
mod playdate.graphics.animation.loop;
mod playdate.graphics.animation;
mod playdate.graphics.animator;
mod playdate.graphics.font;
mod playdate.graphics.image;
mod playdate.graphics.imagetable;
mod playdate.graphics.nineSlice;
mod playdate.graphics.sprite;
mod playdate.graphics.tilemap;
mod playdate.graphics.video;
mod playdate.graphics;
mod playdate.inputHandlers;
mod playdate.inputHandlers;
mod playdate.keyboard;
mod playdate.math;
mod playdate.menu.item;
mod playdate.menu;
mod playdate.pathfinder.graph;
mod playdate.pathfinder.node;
mod playdate.pathfinder;
mod playdate.simulator;
mod playdate.sound.bitcrusher;
mod playdate.sound.channel;
mod playdate.sound.controlsignal;
mod playdate.sound.delayline;
mod playdate.sound.delaylinetap;
mod playdate.sound.effect;
mod playdate.sound.effect;
mod playdate.sound.envelope;
mod playdate.sound.fileplayer;
mod playdate.sound.instrument;
mod playdate.sound.lfo;
mod playdate.sound.micinput;
mod playdate.sound.onepolefilter;
mod playdate.sound.overdrive;
mod playdate.sound.ringmod;
mod playdate.sound.sample;
mod playdate.sound.sampleplayer;
mod playdate.sound.sequence;
mod playdate.sound.signal;
mod playdate.sound.source;
mod playdate.sound.synth;
mod playdate.sound.track;
mod playdate.sound.twopolefilter;
mod playdate.sound;
mod playdate.string;
mod playdate.timer;
mod playdate.ui.crankIndicator;
mod playdate.ui.gridview;
mod playdate.ui;
mod playdate;
mod table;
con playdate.file.kFileAppend: integer = 8;
con playdate.file.kFileRead: integer = 3;
con playdate.file.kFileWrite: integer = 4;
con playdate.geometry.kFlippedX: integer = 1;
con playdate.geometry.kFlippedXY: integer = 3;
con playdate.geometry.kFlippedY: integer = 2;
con playdate.geometry.kUnflipped: integer = 0;
con playdate.graphics.font.kLanguageEnglish: integer = 0;
con playdate.graphics.font.kLanguageJapanese: integer = 1;
con playdate.graphics.font.kVariantBold: integer = 1;
con playdate.graphics.font.kVariantItalic: integer = 2;
con playdate.graphics.font.kVariantNormal: integer = 0;
con playdate.graphics.image.kDitherTypeAtkinson: integer = 10;
con playdate.graphics.image.kDitherTypeBayer2x2: integer = 5;
con playdate.graphics.image.kDitherTypeBayer4x4: integer = 6;
con playdate.graphics.image.kDitherTypeBayer8x8: integer = 7;
con playdate.graphics.image.kDitherTypeBurkes: integer = 9;
con playdate.graphics.image.kDitherTypeDiagonalLine: integer = 1;
con playdate.graphics.image.kDitherTypeFloydSteinberg: integer = 8;
con playdate.graphics.image.kDitherTypeHorizontalLine: integer = 3;
con playdate.graphics.image.kDitherTypeNone: integer = 0;
con playdate.graphics.image.kDitherTypeScreen: integer = 4;
con playdate.graphics.image.kDitherTypeVerticalLine: integer = 2;
con playdate.graphics.kColorBlack: integer = 0;
con playdate.graphics.kColorClear: integer = 2;
con playdate.graphics.kColorWhite: integer = 1;
con playdate.graphics.kColorXOR: integer = 3;
con playdate.graphics.kDrawModeBlackTransparent: integer = 2;
con playdate.graphics.kDrawModeCopy: integer = 0;
con playdate.graphics.kDrawModeFillBlack: integer = 4;
con playdate.graphics.kDrawModeFillWhite: integer = 3;
con playdate.graphics.kDrawModeInverted: integer = 7;
con playdate.graphics.kDrawModeNXOR: integer = 6;
con playdate.graphics.kDrawModeWhiteTransparent: integer = 1;
con playdate.graphics.kDrawModeXOR: integer = 5;
con playdate.graphics.kImageFlippedX: integer = 1;
con playdate.graphics.kImageFlippedXY: integer = 3;
con playdate.graphics.kImageFlippedY: integer = 2;
con playdate.graphics.kImageUnflipped: integer = 0;
con playdate.graphics.kPolygonFillEvenOdd: integer = 1;
con playdate.graphics.kPolygonFillNonZero: integer = 0;
con playdate.graphics.kStrokeCentered: integer = 0;
con playdate.graphics.kStrokeInside: integer = 1;
con playdate.graphics.kStrokeOutside: integer = 2;
con playdate.graphics.sprite.kCollisionTypeBounce: integer = 3;
con playdate.graphics.sprite.kCollisionTypeFreeze: integer = 1;
con playdate.graphics.sprite.kCollisionTypeOverlap: integer = 2;
con playdate.graphics.sprite.kCollisionTypeSlide: integer = 0;
con playdate.kButtonA: integer = 32;
con playdate.kButtonB: integer = 16;
con playdate.kButtonDown: integer = 8;
con playdate.kButtonLeft: integer = 1;
con playdate.kButtonRight: integer = 2;
con playdate.kButtonUp: integer = 4;
con playdate.keyboard.kCapitalizationNormal: integer = 1;
con playdate.keyboard.kCapitalizationSentences: integer = 3;
con playdate.keyboard.kCapitalizationWords: integer = 2;
con playdate.sound.kFormat16bitMono: integer = 2;
con playdate.sound.kFormat16bitStereo: integer = 3;
con playdate.sound.kFormat8bitMono: integer = 0;
con playdate.sound.kFormat8bitStereo: integer = 1;
con playdate.sound.kLFOSampleAndHold: integer = 3;
con playdate.sound.kLFOSawtoothDown: integer = 5;
con playdate.sound.kLFOSawtoothUp: integer = 4;
con playdate.sound.kLFOSine: integer = 2;
con playdate.sound.kLFOSquare: integer = 0;
con playdate.sound.kLFOTriangle: integer = 1;
con playdate.sound.kWaveNoise: integer = 3;
con playdate.sound.kWavePODigital: integer = 6;
con playdate.sound.kWavePOPhase: integer = 5;
con playdate.sound.kWavePOVosim: integer = 7;
con playdate.sound.kWaveSawtooth: integer = 4;
con playdate.sound.kWaveSine: integer = 2;
con playdate.sound.kWaveSquare: integer = 0;
con playdate.sound.kWaveTriangle: integer = 1;
obj playdate._DateTime = { year: integer, month: integer, day: integer, weekday: integer, hour: integer, minute: integer, second: integer, millisecond: integer, };
obj playdate._PowerStatus = { charging: boolean, USB: boolean, screws: boolean, };
obj playdate._SystemStats = { " kernel": number, " game": number, " audio": number, };
obj playdate._metadata = { name: string, author: string, description: string, bundleID: string, version: string, buildNumber: integer, pdxversion: integer, imagePath?: string, launchSoundPath?: string, contentWarning?: string, contentWarning2?: string, ...: string, };
obj playdate._systeminfo = { buildtime: string, commit: string, pdxcompatversion: integer; pdxversion: integer, };
obj playdate.file._ModTime = { year: integer, month: integer, day: integer, hour: integer, minute: integer, second: integer, };
obj playdate.file.file;
obj playdate.frameTimer = { delay: integer, discardOnCompletion: boolean, duration: integer, frame: integer, repeats: boolean, reverses: boolean, timerEndedArgs: any, };
obj playdate.geometry.affineTransform;
obj playdate.geometry.arc = { x: integer, y: integer, radius: integer, startAngle: number, endAngle: number, direction: boolean, };
obj playdate.geometry.lineSegment = { x1: integer, y1: integer, x2: integer, y2: integer, };
obj playdate.geometry.point = { x: number, y: number, };
obj playdate.geometry.polygon;
obj playdate.geometry.rect = { x: number, y: number, width: number, height: number, top: number, bottom: number, left: number, right: number, size: playdate.geometry.size, };
obj playdate.geometry.size = { width: number, height: number, };
obj playdate.geometry.vector2D = { dx: number, dy: number, };
obj playdate.graphics.animation.blinker = { onDuration: integer, offDuration: integer, loop: boolean, cycles: integer, default: boolean, counter: integer, on: boolean, running: boolean, };
obj playdate.graphics.animation.loop = { delay: number, startFrame: integer, endFrame: integer, frame: integer, step: integer, shouldLoop: boolean, paused: boolean, };
obj playdate.graphics.animator = { repeatCount: integer, reverses: integer, easingAmplitude: number, easingPeriod: number, s?: number, a?: number, p?: number, };
obj playdate.graphics.font;
obj playdate.graphics.image = { x: integer, y: integer, width: integer, height: integer, };
obj playdate.graphics.imagetable;
obj playdate.graphics.nineSlice = { innerRect: playdate.geometry.rect, minWidth: integer, minHeight: integer, };
obj playdate.graphics.sprite = { x: integer, y: integer, width: integer, height: integer, collisionResponse?: (playdate.graphics.sprite._CollisionType|fun(self: playdate.graphics.sprite, other: playdate.graphics.sprite) -> playdate.graphics.sprite._CollisionType), update?: fun()->nil, };
obj playdate.graphics.sprite._CollisionData = { sprite: playdate.graphics.sprite, other: playdate.graphics.sprite, type: playdate.graphics.sprite._CollisionType, overlaps: boolean, ti: number, move: playdate.geometry.vector2D, normal: playdate.geometry.vector2D, touch: playdate.geometry.point, spriteRect: playdate.geometry.rect, otherRect: playdate.geometry.rect, bounce?: playdate.geometry.point, slide?: playdate.geometry.point, };
obj playdate.graphics.sprite._CollisionInfo = { sprite: playdate.graphics.sprite, entryPoint: playdate.geometry.point, exitPoint: playdate.geometry.point, t1: number, t2: number, };
obj playdate.graphics.tilemap;
obj playdate.graphics.video;
obj playdate.inputHandlers._InputHandler = { AButtonDown?: fun(), AButtonHeld?: fun(), AButtonUp?: fun(), BButtonDown?: fun(), BButtonHeld?: fun(), BButtonUp?: fun(), downButtonDown?: fun(), downButtonUp?: fun(), leftButtonDown?: fun(), leftButtonUp?: fun(), rightButtonDown?: fun(), rightButtonUp?: fun(), upButtonDown?: fun(), upButtonUp?: fun(), cranked?: fun(change:number, acceleratedChange:number)};
obj playdate.keyboard = { text: string, };
obj playdate.menu.item = { title: string, value: (integer|boolean|string)};
obj playdate.pathfinder.graph;
obj playdate.pathfinder.node = { x: integer, y: integer, id: integer, };
obj playdate.sound.bitcrusher: playdate.sound.effect;
obj playdate.sound.channel;
obj playdate.sound.controlsignal._ControlSignalEvent = { step: integer, value: number, interpolate?: boolean, };
obj playdate.sound.controlsignal: playdate.sound.signal = { events: playdate.sound.controlsignal._ControlSignalEvent };
obj playdate.sound.delayline: playdate.sound.effect;
obj playdate.sound.delaylinetap: playdate.sound.source;
obj playdate.sound.effect;
obj playdate.sound.effect;
obj playdate.sound.envelope: playdate.sound.signal;
obj playdate.sound.fileplayer: playdate.sound.source;
obj playdate.sound.instrument: playdate.sound.source;
obj playdate.sound.lfo: playdate.sound.signal;
obj playdate.sound.onepolefilter: playdate.sound.effect;
obj playdate.sound.overdrive: playdate.sound.effect;
obj playdate.sound.ringmod: playdate.sound.effect;
obj playdate.sound.sample;
obj playdate.sound.sampleplayer: playdate.sound.source;
obj playdate.sound.sequence;
obj playdate.sound.signal;
obj playdate.sound.source;
obj playdate.sound.synth: playdate.sound.source;
obj playdate.sound.track._SoundTrackNote = { step: integer, note: number, length: integer, velocity: number, };
obj playdate.sound.track._SoundTrackNoteIn = { step: integer, note: number|string, length: integer, velocity: number,};
obj playdate.sound.track;
obj playdate.sound.twopolefilter: playdate.sound.effect;
obj playdate.timer = { currentTime: integer, delay: integer, discardOnCompletion: boolean, duration: integer, timeLeft: integer, repeats: boolean, reverses: boolean, timerEndedArgs: any[]};
obj playdate.ui.gridview = { needsDisplay:boolean, backgroundImage: (playdate.graphics.image|playdate.graphics.nineSlice), isScrolling:boolean, scrollEasingFunction:fun(t:number, b:number, c:number, d:number, a?:number, p?:number): number, easingAmplitude?: number, easingPeriod?: number, changeRowOnColumnWrap: boolean, scrollCellsToCenter: boolean, };
let playdate.argv:Â string[];
let playdate.isSimulator: boolean;
let playdate.metadata: playdate._metadata;
let playdate.systeminfo: playdate._systeminfo;
let playdate.ui.crankIndicator.clockwise: boolean;
fun json.decode(string: string) -> table;
fun json.decodeFile(file: playdate.file.file) -> table;
fun json.decodeFile(path: string) -> table;
fun json.encode(table: table) -> string;
fun json.encodePretty(table: table) -> string;
fun json.encodeToFile(file: playdate.file.file, pretty: boolean, table: table) -> nil;
fun json.encodeToFile(path: string, pretty?: boolean, table?: table) -> nil;
fun playdate.AButtonDown() -> nil;
fun playdate.AButtonHeld() -> nil;
fun playdate.AButtonUp() -> nil;
fun playdate.BButtonDown() -> nil;
fun playdate.BButtonHeld() -> nil;
fun playdate.BButtonUp() -> nil;
fun playdate.GMTTimeFromEpoch(seconds: integer, milliseconds: integer) -> playdate._DateTime;
fun playdate.accelerometerIsRunning() -> boolean;
fun playdate.apiVersion() -> (api_version: integer, runtime_minimum_api_version: integer);
fun playdate.buttonIsPressed(button: integer) -> boolean;
fun playdate.buttonJustPressed(button: integer) -> boolean;
fun playdate.buttonJustReleased(button: integer) -> boolean;
fun playdate.clearConsole() -> nil;
fun playdate.crankDocked() -> nil;
fun playdate.crankUndocked() -> nil;
fun playdate.cranked(change: number, acceleratedChange: number) -> nil;
fun playdate.datastore.delete(filename?: string) -> boolean;
fun playdate.datastore.read(filename?: string) -> table?;
fun playdate.datastore.readImage(path: string) -> playdate.graphics.image?;
fun playdate.datastore.write(table: table, filename?: string, pretty: boolean) -> nil;
fun playdate.datastore.writeImage(image: playdate.graphics.image, path: string) -> nil;
fun playdate.debugDraw() -> nil;
fun playdate.deviceDidUnlock() -> nil;
fun playdate.deviceWillLock() -> nil;
fun playdate.deviceWillSleep() -> nil;
fun playdate.display.flush() -> nil;
fun playdate.display.getHeight() -> integer;
fun playdate.display.getInverted() -> boolean;
fun playdate.display.getMosaic() -> (x: integer, y: integer);
fun playdate.display.getOffset() -> (x: integer, y: integer);
fun playdate.display.getRect() -> playdate.geometry.rect;
fun playdate.display.getRefreshRate() -> integer;
fun playdate.display.getScale() -> integer;
fun playdate.display.getSize() -> (width: integer, height: integer);
fun playdate.display.getWidth() -> integer;
fun playdate.display.loadImage(path: string) -> nil;
fun playdate.display.setFlipped(x: integer, y: integer) -> nil;
fun playdate.display.setInverted(flag: boolean) -> nil;
fun playdate.display.setMosaic(x: integer, y: integer) -> nil;
fun playdate.display.setOffset(x: integer, y: integer) -> nil;
fun playdate.display.setRefreshRate(rate: number) -> nil;
fun playdate.display.setScale(scale: integer) -> nil;
fun playdate.downButtonDown() -> nil;
fun playdate.downButtonUp() -> nil;
fun playdate.drawFPS(x: integer, y: integer) -> nil;
fun playdate.easingFunctions.inBack(t: number, b: number, c: number, d: number, s?: number) -> number;
fun playdate.easingFunctions.inBounce(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.inCirc(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.inCubic(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.inElastic(t: number, b: number, c: number, d: number, a?: number, p?: number) -> number;
fun playdate.easingFunctions.inExpo(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.inOutBack(t: number, b: number, c: number, d: number, s?: number) -> number;
fun playdate.easingFunctions.inOutBounce(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.inOutCirc(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.inOutCubic(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.inOutElastic(t: number, b: number, c: number, d: number, a?: number, p?: number) -> number;
fun playdate.easingFunctions.inOutExpo(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.inOutQuad(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.inOutQuart(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.inOutQuint(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.inOutSine(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.inQuad(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.inQuart(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.inQuint(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.inSine(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.linear(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.outBack(t: number, b: number, c: number, d: number, s?: number) -> number;
fun playdate.easingFunctions.outBounce(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.outCirc(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.outCubic(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.outElastic(t: number, b: number, c: number, d: number, a?: number, p?: number) -> number;
fun playdate.easingFunctions.outExpo(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.outInBack(t: number, b: number, c: number, d: number, s?: number) -> number;
fun playdate.easingFunctions.outInBounce(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.outInCirc(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.outInCubic(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.outInElastic(t: number, b: number, c: number, d: number, a?: number, p?: number) -> number;
fun playdate.easingFunctions.outInExpo(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.outInQuad(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.outInQuart(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.outInQuint(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.outInSine(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.outQuad(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.outQuart(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.outQuint(t: number, b: number, c: number, d: number) -> number;
fun playdate.easingFunctions.outSine(t: number, b: number, c: number, d: number) -> number;
fun playdate.epochFromGMTTime(time: playdate._DateTime) -> (seconds: integer, milliseconds: integer);
fun playdate.epochFromTime(time: table) -> (seconds: integer, milliseconds: integer);
fun playdate.file.delete(path: string, recursive?: boolean) -> boolean;
fun playdate.file.exists(path: string) -> boolean;
fun playdate.file.file:close() -> nil;
fun playdate.file.file:flush() -> nil;
fun playdate.file.file:read(numberOfBytes: integer) -> (numberOfBytes: integer, error: string);
fun playdate.file.file:readline() -> string;
fun playdate.file.file:seek(offset: integer) -> nil;
fun playdate.file.file:tell() -> integer;
fun playdate.file.file:write(string: string) -> (bytes_written: integer, error: string?);
fun playdate.file.getSize(path: string) -> integer;
fun playdate.file.getType(path: string) -> string;
fun playdate.file.isdir(path: string) -> boolean;
fun playdate.file.listFiles(path: string, showhidden?: boolean) -> string[];
fun playdate.file.load(path: string, env?: table) -> function;
fun playdate.file.mkdir(path: string) -> nil;
fun playdate.file.modtime(path: string) -> playdate.file._ModTime;
fun playdate.file.open(path: string, mode?: integer) -> (file: playdate.file.file?, error: string?);
fun playdate.file.rename(path: string, newPath: string) -> boolean;
fun playdate.file.run(path: string, env?: table) -> nil;
fun playdate.frameTimer.allTimers() -> playdate.frameTimer[];
fun playdate.frameTimer.new(duration: integer, callback: function, ...: any) -> playdate.frameTimer;
fun playdate.frameTimer.new(duration: integer, startValue?: number, endValue?: number, easingFunction?: function) -> playdate.frameTimer;
fun playdate.frameTimer.performAfterDelay(delay: integer, callback: function, ...: any) -> nil;
fun playdate.frameTimer.updateTimers() -> nil;
fun playdate.frameTimer:pause() -> nil;
fun playdate.frameTimer:remove() -> nil;
fun playdate.frameTimer:reset() -> nil;
fun playdate.frameTimer:start() -> nil;
fun playdate.gameWillPause() -> nil;
fun playdate.gameWillResume() -> nil;
fun playdate.gameWillTerminate() -> nil;
fun playdate.geometry.affineTransform.new() -> playdate.geometry.affineTransform;
fun playdate.geometry.affineTransform.new(m11: number, m12: number, m21: number, m22: number, tx: number, ty: number) -> playdate.geometry.affineTransform;
fun playdate.geometry.affineTransform:__mul(p: playdate.geometry.point) -> playdate.geometry.point;
fun playdate.geometry.affineTransform:__mul(t: playdate.geometry.affineTransform) -> playdate.geometry.affineTransform;
fun playdate.geometry.affineTransform:__mul(v: playdate.geometry.vector2D) -> playdate.geometry.vector2D;
fun playdate.geometry.affineTransform:concat(af: playdate.geometry.affineTransform) -> nil;
fun playdate.geometry.affineTransform:copy() -> playdate.geometry.affineTransform;
fun playdate.geometry.affineTransform:invert() -> nil;
fun playdate.geometry.affineTransform:reset() -> nil;
fun playdate.geometry.affineTransform:rotate(angle: number, point?: playdate.geometry.point) -> nil;
fun playdate.geometry.affineTransform:rotate(angle: number, x?: integer, y?: integer) -> nil;
fun playdate.geometry.affineTransform:rotatedBy(angle: number, point?: playdate.geometry.point) -> playdate.geometry.affineTransform;
fun playdate.geometry.affineTransform:rotatedBy(angle: number, x?: integer, y?: integer) -> playdate.geometry.affineTransform;
fun playdate.geometry.affineTransform:scale(sx: number, sy?: number) -> nil;
fun playdate.geometry.affineTransform:scaledBy(sx: number, sy?: number) -> playdate.geometry.affineTransform;
fun playdate.geometry.affineTransform:skew(sx: number, sy: number) -> nil;
fun playdate.geometry.affineTransform:skewedBy(sx: number, sy: number) -> playdate.geometry.affineTransform;
fun playdate.geometry.affineTransform:transformAABB(r: playdate.geometry.rect) -> nil;
fun playdate.geometry.affineTransform:transformLineSegment(ls: playdate.geometry.lineSegment) -> nil;
fun playdate.geometry.affineTransform:transformPoint(p: playdate.geometry.point) -> nil;
fun playdate.geometry.affineTransform:transformPolygon(p: playdate.geometry.polygon) -> nil;
fun playdate.geometry.affineTransform:transformXY(x: integer, y: integer) -> (x: number, y: number);
fun playdate.geometry.affineTransform:transformedAABB(r: playdate.geometry.rect) -> playdate.geometry.rect;
fun playdate.geometry.affineTransform:transformedLineSegment(ls: playdate.geometry.lineSegment) -> playdate.geometry.lineSegment;
fun playdate.geometry.affineTransform:transformedPoint(p: playdate.geometry.point) -> playdate.geometry.point;
fun playdate.geometry.affineTransform:transformedPolygon(p: playdate.geometry.polygon) -> playdate.geometry.polygon;
fun playdate.geometry.affineTransform:translate(dx: integer, dy: integer) -> nil;
fun playdate.geometry.affineTransform:translatedBy(dx: integer, dy: integer) -> playdate.geometry.affineTransform;
fun playdate.geometry.arc.new(x: integer, y: integer, radius: number, startAngle: number, endAngle: number, direction?: boolean) -> playdate.geometry.arc;
fun playdate.geometry.arc:copy() -> playdate.geometry.arc;
fun playdate.geometry.arc:isClockwise() -> boolean;
fun playdate.geometry.arc:length() -> number;
fun playdate.geometry.arc:pointOnArc(distance: integer, extend: boolean) -> playdate.geometry.point;
fun playdate.geometry.arc:setIsClockwise(flag: boolean) -> nil;
fun playdate.geometry.distanceToPoint(x1: integer, y1: integer, x2: integer, y2: integer) -> number;
fun playdate.geometry.lineSegment.fast_intersection(x1: integer, y1: integer, x2: integer, y2: integer, x3: integer, y3: integer, x4: integer, y4: integer) -> (intersects: boolean, x: number?, y: number?);
fun playdate.geometry.lineSegment.new(x1: integer, y1: integer, x2: integer, y2: integer) -> playdate.geometry.lineSegment;
fun playdate.geometry.lineSegment:closestPointOnLineToPoint(p: playdate.geometry.point) -> playdate.geometry.point;
fun playdate.geometry.lineSegment:copy() -> playdate.geometry.lineSegment;
fun playdate.geometry.lineSegment:intersectsLineSegment(ls: playdate.geometry.lineSegment) -> (intersects: boolean, intersection: playdate.geometry.point?);
fun playdate.geometry.lineSegment:intersectsPolygon(poly: playdate.geometry.polygon) -> (intersects: boolean, intersectionPoints: playdate.geometry.point[]?);
fun playdate.geometry.lineSegment:intersectsRect(rect: playdate.geometry.rect) -> (intersects: boolean, intersectionPoints: playdate.geometry.point[]?);
fun playdate.geometry.lineSegment:length() -> number;
fun playdate.geometry.lineSegment:midPoint() -> playdate.geometry.point;
fun playdate.geometry.lineSegment:offset(dx: integer, dy: integer) -> nil;
fun playdate.geometry.lineSegment:offsetBy(dx: integer, dy: integer) -> playdate.geometry.lineSegment;
fun playdate.geometry.lineSegment:pointOnLine(distance: integer, extend?: boolean) -> playdate.geometry.point;
fun playdate.geometry.lineSegment:segmentVector() -> playdate.geometry.vector2D;
fun playdate.geometry.lineSegment:unpack() -> (x1: number, y1: number, x2: number, y2: number);
fun playdate.geometry.point.new(x: integer, y: integer) -> playdate.geometry.point;
fun playdate.geometry.point:__add(v: playdate.geometry.vector2D) -> playdate.geometry.point;
fun playdate.geometry.point:__concat(p2: playdate.geometry.point) -> playdate.geometry.lineSegment;
fun playdate.geometry.point:__mul(t: playdate.geometry.affineTransform) -> playdate.geometry.point;
fun playdate.geometry.point:__sub(p2: playdate.geometry.point) -> playdate.geometry.vector2D;
fun playdate.geometry.point:copy() -> playdate.geometry.point;
fun playdate.geometry.point:distanceToPoint(p: playdate.geometry.point) -> number;
fun playdate.geometry.point:offset(dx: integer, dy: integer) -> nil;
fun playdate.geometry.point:offsetBy(dx: integer, dy: integer) -> playdate.geometry.point;
fun playdate.geometry.point:squaredDistanceToPoint(p: playdate.geometry.point) -> number;
fun playdate.geometry.point:unpack() -> (x: number, y: number);
fun playdate.geometry.polygon.new(numberOfVertices: integer) -> playdate.geometry.polygon;
fun playdate.geometry.polygon.new(p1: playdate.geometry.point, p2: playdate.geometry.point, ...: integer) -> playdate.geometry.polygon;
fun playdate.geometry.polygon.new(x1: integer, y1: integer, x2: integer, y2: integer, ...: integer) -> playdate.geometry.polygon;
fun playdate.geometry.polygon:__mul(t: playdate.geometry.affineTransform) -> playdate.geometry.polygon;
fun playdate.geometry.polygon:close() -> nil;
fun playdate.geometry.polygon:containsPoint(p: playdate.geometry.point, fillRule?: integer) -> boolean;
fun playdate.geometry.polygon:containsPoint(x: integer, y: integer, fillRule?: integer) -> boolean;
fun playdate.geometry.polygon:copy() -> playdate.geometry.polygon;
fun playdate.geometry.polygon:count() -> integer;
fun playdate.geometry.polygon:getBounds() -> (x: number, y: number, width: number, height: number);
fun playdate.geometry.polygon:getBoundsRect() -> playdate.geometry.rect;
fun playdate.geometry.polygon:getPointAt(n: integer) -> playdate.geometry.point;
fun playdate.geometry.polygon:intersects(p: playdate.geometry.point) -> boolean;
fun playdate.geometry.polygon:isClosed() -> boolean;
fun playdate.geometry.polygon:length() -> number;
fun playdate.geometry.polygon:pointOnPolygon(distance: integer, extend?: boolean) -> playdate.geometry.point;
fun playdate.geometry.polygon:setPointAt(n: integer, x: integer, y: integer) -> nil;
fun playdate.geometry.polygon:translate(dx: integer, dy: integer) -> nil;
fun playdate.geometry.rect.fast_intersection(x1: integer, y1: integer, w1: integer, h1: integer, x2: integer, y2: integer, w2: integer, h2: integer) -> (x: number, y: number, width: number, height: number);
fun playdate.geometry.rect.fast_union(x1: integer, y1: integer, w1: integer, h1: integer, x2: integer, y2: integer, w2: integer, h2: integer) -> (x: number, y: number, width: number, height: number);
fun playdate.geometry.rect.new(x: integer, y: integer, width: integer, height: integer) -> playdate.geometry.rect;
fun playdate.geometry.rect:centerPoint() -> playdate.geometry.point;
fun playdate.geometry.rect:containsPoint(p: playdate.geometry.point) -> boolean;
fun playdate.geometry.rect:containsPoint(x: integer, y: integer) -> boolean;
fun playdate.geometry.rect:containsRect(r2: playdate.geometry.rect) -> boolean;
fun playdate.geometry.rect:containsRect(x: integer, y: integer, width: integer, height: integer) -> boolean;
fun playdate.geometry.rect:copy() -> playdate.geometry.rect;
fun playdate.geometry.rect:flipRelativeToRect(r2: playdate.geometry.rect, flip: integer| -> nil;
fun playdate.geometry.rect:inset(dx: integer, dy: integer) -> nil;
fun playdate.geometry.rect:insetBy(dx: integer, dy: integer) -> playdate.geometry.rect;
fun playdate.geometry.rect:intersection(r2: playdate.geometry.rect) -> playdate.geometry.rect;
fun playdate.geometry.rect:intersects(r2: playdate.geometry.rect) -> boolean;
fun playdate.geometry.rect:isEmpty() -> boolean;
fun playdate.geometry.rect:isEqual(r2: playdate.geometry.rect) -> boolean;
fun playdate.geometry.rect:offset(dx: integer, dy: integer) -> nil;
fun playdate.geometry.rect:offsetBy(dx: integer, dy: integer) -> playdate.geometry.rect;
fun playdate.geometry.rect:toPolygon() -> playdate.geometry.polygon;
fun playdate.geometry.rect:union(r2: playdate.geometry.rect) -> playdate.geometry.rect;
fun playdate.geometry.rect:unpack() -> (x: number, y: number, width: number, height: number);
fun playdate.geometry.size.new(width: integer, height: integer) -> playdate.geometry.size;
fun playdate.geometry.size:copy() -> playdate.geometry.size;
fun playdate.geometry.size:unpack() -> (width: number, height: number);
fun playdate.geometry.squaredDistanceToPoint(x1: integer, y1: integer, x2: integer, y2: integer) -> number;
fun playdate.geometry.vector2D.new(x: integer, y: integer) -> playdate.geometry.vector2D;
fun playdate.geometry.vector2D.newPolar(length: number, angle: number) -> playdate.geometry.vector2D;
fun playdate.geometry.vector2D:__add(v2: playdate.geometry.vector2D) -> playdate.geometry.vector2D;
fun playdate.geometry.vector2D:__div(s: number) -> playdate.geometry.vector2D;
fun playdate.geometry.vector2D:__mul(s: number) -> playdate.geometry.vector2D;
fun playdate.geometry.vector2D:__mul(t: playdate.geometry.affineTransform) -> playdate.geometry.vector2D;
fun playdate.geometry.vector2D:__mul(v2: playdate.geometry.vector2D) -> playdate.geometry.vector2D;
fun playdate.geometry.vector2D:__sub(v2: playdate.geometry.vector2D) -> playdate.geometry.vector2D;
fun playdate.geometry.vector2D:__unm() -> playdate.geometry.vector2D;
fun playdate.geometry.vector2D:addVector(v: playdate.geometry.vector2D) -> nil;
fun playdate.geometry.vector2D:angleBetween(v: playdate.geometry.vector2D) -> number;
fun playdate.geometry.vector2D:copy() -> playdate.geometry.vector2D;
fun playdate.geometry.vector2D:dotProduct(v: playdate.geometry.vector2D) -> number;
fun playdate.geometry.vector2D:leftNormal() -> playdate.geometry.vector2D;
fun playdate.geometry.vector2D:magnitude() -> number;
fun playdate.geometry.vector2D:magnitudeSquared() -> number;
fun playdate.geometry.vector2D:normalize() -> nil;
fun playdate.geometry.vector2D:normalized() -> playdate.geometry.vector2D;
fun playdate.geometry.vector2D:projectAlong(v: playdate.geometry.vector2D) -> nil;
fun playdate.geometry.vector2D:projectedAlong(v: playdate.geometry.vector2D) -> playdate.geometry.vector2D;
fun playdate.geometry.vector2D:rightNormal() -> playdate.geometry.vector2D;
fun playdate.geometry.vector2D:scale(s: number) -> nil;
fun playdate.geometry.vector2D:scaledBy(s: number) -> playdate.geometry.vector2D;
fun playdate.geometry.vector2D:unpack() -> (x: number, y: number);
fun playdate.getBatteryPercentage() -> integer;
fun playdate.getBatteryVoltage() -> number;
fun playdate.getButtonState() -> (current: integer, pressed: integer, released: integer);
fun playdate.getCrankChange() -> number;
fun playdate.getCrankPosition() -> number;
fun playdate.getCrankTicks(ticksPerRevolution: number) -> number;
fun playdate.getCurrentTimeMilliseconds() -> integer;
fun playdate.getElapsedTime() -> number;
fun playdate.getFPS() -> number;
fun playdate.getFlipped() -> boolean;
fun playdate.getGMTTime() -> playdate._DateTime;
fun playdate.getPowerStatus() -> playdate._PowerStatus;
fun playdate.getReduceFlashing() -> boolean;
fun playdate.getSecondsSinceEpoch() -> (seconds: integer, milliseconds: integer);
fun playdate.getStats() -> playdate._SystemStats;
fun playdate.getSystemLanguage() -> integer;
fun playdate.getSystemMenu() -> playdate.menu;
fun playdate.getTime() -> playdate._DateTime;
fun playdate.graphics.animation.blinker.new(onDuration?: integer, offDuration?: integer, loop?: boolean, cycles?: integer, default?: boolean) -> playdate.graphics.animation.blinker;
fun playdate.graphics.animation.blinker.stopAll() -> nil;
fun playdate.graphics.animation.blinker.updateAll() -> nil;
fun playdate.graphics.animation.blinker:remove() -> nil;
fun playdate.graphics.animation.blinker:start(onDuration?: integer, offDuration?: integer, loop?: boolean, cycles?: integer, default?: boolean) -> nil;
fun playdate.graphics.animation.blinker:startLoop() -> nil;
fun playdate.graphics.animation.blinker:stop() -> nil;
fun playdate.graphics.animation.blinker:update() -> nil;
fun playdate.graphics.animation.loop.new(delay?: number, imageTable?: playdate.graphics.imagetable, shouldLoop?: boolean) -> playdate.graphics.animation.loop;
fun playdate.graphics.animation.loop:draw(x: integer, y: integer, flip?: (integer|string)) -> nil;
fun playdate.graphics.animation.loop:image() -> playdate.graphics.image;
fun playdate.graphics.animation.loop:isValid() -> boolean;
fun playdate.graphics.animation.loop:setImageTable(imageTable: playdate.graphics.imagetable) -> nil;
fun playdate.graphics.animator.new(duration: integer, arc: playdate.geometry.arc, easingFunction?: function, startTimeOffset?: integer) -> playdate.graphics.animator;
fun playdate.graphics.animator.new(duration: integer, lineSegment: playdate.geometry.lineSegment, easingFunction?: function, startTimeOffset?: integer) -> playdate.graphics.animator;
fun playdate.graphics.animator.new(duration: integer, polygon: playdate.geometry.polygon, easingFunction?: function, startTimeOffset?: integer) -> playdate.graphics.animator;
fun playdate.graphics.animator.new(duration: integer, startValue: number|playdate.geometry.point, endValue: number|playdate.geometry.point, easingFunction?: function, startTimeOffset?: integer) -> playdate.graphics.animator;
fun playdate.graphics.animator.new(durations: integer, parts: number[], easingFunctions: function[], startTimeOffset?: integer) -> playdate.graphics.animator;
fun playdate.graphics.animator:currentValue() -> number|playdate.geometry.point;
fun playdate.graphics.animator:ended() -> boolean;
fun playdate.graphics.animator:progress() -> number;
fun playdate.graphics.animator:reset(duration?: integer) -> nil;
fun playdate.graphics.animator:valueAtTime(time: number) -> number|playdate.geometry.point;
fun playdate.graphics.checkAlphaCollision(image1: playdate.graphics.image, x1: integer, y1: integer, flip1: integer, image2: playdate.graphics.image, x2: integer, y2: integer, flip2: integer) -> boolean;
fun playdate.graphics.clear(color?: integer) -> nil;
fun playdate.graphics.clearClipRect() -> nil;
fun playdate.graphics.clearStencil() -> nil;
fun playdate.graphics.clearStencilImage() -> nil;
fun playdate.graphics.drawArc(arc: playdate.geometry.arc) -> nil;
fun playdate.graphics.drawArc(x: integer, y: integer, radius: number, startAngle: number, endAngle: number) -> nil;
fun playdate.graphics.drawCircleAtPoint(p: playdate.geometry.point, radius: number) -> nil;
fun playdate.graphics.drawCircleAtPoint(x: integer, y: integer, radius: number) -> nil;
fun playdate.graphics.drawCircleInRect(r: playdate.geometry.rect) -> nil;
fun playdate.graphics.drawCircleInRect(x: integer, y: integer, width: integer, height: integer) -> nil;
fun playdate.graphics.drawEllipseInRect(rect: playdate.geometry.rect, startAngle?: number, endAngle?: number) -> nil;
fun playdate.graphics.drawEllipseInRect(x: integer, y: integer, width: integer, height: integer, startAngle?: number, endAngle?: number) -> nil;
fun playdate.graphics.drawLine(x1: integer, y1: integer, x2: integer, y2: integer) -> nil;
fun playdate.graphics.drawLocalizedText(key: string, x: integer, y: integer, language?: (integer|string), leadingAdjustment?: integer) -> nil;
fun playdate.graphics.drawLocalizedTextAligned(text: string, x: integer, y: integer, alignment: integer, language?: (integer|string), leadingAdjustment?: integer) -> nil;
fun playdate.graphics.drawLocalizedTextInRect(text: string, rect: playdate.geometry.rect, leadingAdjustment?: integer, truncationString?: string, alignment?: integer, font?: playdate.graphics.font, language?: (integer|string) -> nil;
fun playdate.graphics.drawLocalizedTextInRect(text: string, x: integer, y: integer, width: integer, height: integer, leadingAdjustment?: integer, truncationString?: string, alignment?: integer, font?: playdate.graphics.font, language?: (integer|string) -> nil;
fun playdate.graphics.drawPixel(x: integer, y: integer) -> nil;
fun playdate.graphics.drawPolygon(p: playdate.geometry.polygon) -> nil;
fun playdate.graphics.drawPolygon(x1: integer, y1: integer, x2: integer, y2: integer, ...?: integer) -> nil;
fun playdate.graphics.drawRect(r: playdate.geometry.rect) -> nil;
fun playdate.graphics.drawRect(x: integer, y: integer, w: integer, h: integer) -> nil;
fun playdate.graphics.drawRoundRect(r: playdate.geometry.rect, radius: number) -> nil;
fun playdate.graphics.drawRoundRect(x: integer, y: integer, w: integer, h: integer, radius: number) -> nil;
fun playdate.graphics.drawSineWave(startX: integer, startY: integer, endX: integer, endY: integer, startAmplitude: integer, endAmplitude: integer, period: integer, phaseShift?: integer) -> nil;
fun playdate.graphics.drawText(text: string, x: integer, y: integer, fontFamily?: table<integer, playdate.graphics.font>, leadingAdjustment?: integer) -> nil;
fun playdate.graphics.drawTextAligned(text: string, x: integer, y: integer, alignment: integer, leadingAdjustment?: integer) -> nil;
fun playdate.graphics.drawTextInRect(text: string, rect: playdate.geometry.rect, leadingAdjustment?: integer, truncationString?: string, alignment?: integer, font?: playdate.graphics.font) -> nil;
fun playdate.graphics.drawTextInRect(text: string, x: integer, y: integer, width: integer, height: integer, leadingAdjustment?: integer, truncationString?: string, alignment?: integer, font?: playdate.graphics.font) -> nil;
fun playdate.graphics.drawTriangle(x1: integer, y1: integer, x2: integer, y2: integer, x3: integer, y3: integer) -> nil;
fun playdate.graphics.fillCircleAtPoint(p: playdate.geometry.point, radius: number) -> nil;
fun playdate.graphics.fillCircleAtPoint(x: integer, y: integer, radius: number) -> nil;
fun playdate.graphics.fillCircleInRect(r: playdate.geometry.rect) -> nil;
fun playdate.graphics.fillCircleInRect(x: integer, y: integer, width: integer, height: integer) -> nil;
fun playdate.graphics.fillEllipseInRect(rect: playdate.geometry.rect, startAngle?: number, endAngle?: number) -> nil;
fun playdate.graphics.fillEllipseInRect(x: integer, y: integer, width: integer, height: integer, startAngle?: number, endAngle?: number) -> nil;
fun playdate.graphics.fillPolygon(p: playdate.geometry.polygon) -> nil;
fun playdate.graphics.fillPolygon(x1: integer, y1: integer, x2: integer, y2: integer, ...?: integer) -> nil;
fun playdate.graphics.fillRect(r: playdate.geometry.rect) -> nil;
fun playdate.graphics.fillRect(x: integer, y: integer, width: integer, height: integer) -> nil;
fun playdate.graphics.fillRoundRect(r: playdate.geometry.rect, radius: number) -> nil;
fun playdate.graphics.fillRoundRect(x: integer, y: integer, w: integer, h: integer, radius: number) -> nil;
fun playdate.graphics.fillTriangle(x1: integer, y1: integer, x2: integer, y2: integer, x3: integer, y3: integer) -> nil;
fun playdate.graphics.font.new(path: string) -> playdate.graphics.font;
fun playdate.graphics.font.newFamily(fontPaths: table<integer, string>) -> playdate.graphics.font[];
fun playdate.graphics.font:drawText(text: string, x: integer, y: integer, leadingAdjustment?: integer) -> nil;
fun playdate.graphics.font:drawTextAligned(text: string, x: integer, y: integer, alignment: integer, leadingAdjustment?: integer) -> nil;
fun playdate.graphics.font:getGlyph(character: string) -> playdate.graphics.image;
fun playdate.graphics.font:getHeight() -> integer;
fun playdate.graphics.font:getLeading() -> integer;
fun playdate.graphics.font:getTextWidth(text: string) -> integer;
fun playdate.graphics.font:getTracking() -> integer;
fun playdate.graphics.font:setLeading(pixels: integer) -> nil;
fun playdate.graphics.font:setTracking(pixels: integer) -> nil;
fun playdate.graphics.generateQRCode(stringToEncode: string, desiredEdgeDimension: integer, callback: function) -> nil;
fun playdate.graphics.getBackgroundColor() -> integer;
fun playdate.graphics.getClipRect() -> (x: integer, y: integer, width: integer, height: integer);
fun playdate.graphics.getColor() -> integer;
fun playdate.graphics.getDisplayImage() -> playdate.graphics.image;
fun playdate.graphics.getDrawOffset() -> (x: integer, y: integer);
fun playdate.graphics.getFont(variant?: (integer|string) -> playdate.graphics.font;
fun playdate.graphics.getFontTracking() -> integer;
fun playdate.graphics.getImageDrawMode() -> integer;
fun playdate.graphics.getLineWidth() -> integer;
fun playdate.graphics.getLocalizedText(key: string, language?: (integer|string) -> string;
fun playdate.graphics.getScreenClipRect() -> (x: integer, y: integer, width: integer, height: integer);
fun playdate.graphics.getStrokeLocation() -> integer;
fun playdate.graphics.getSystemFont(variant?: (integer|string) -> playdate.graphics.font;
fun playdate.graphics.getTextSize(str: string, fontFamily?: table<integer, playdate.graphics.font>, leadingAdjustment?: integer) -> (width: integer, height: integer);
fun playdate.graphics.getTextSizeForMaxWidth(text: string, maxWidth: integer, leadingAdjustment?: integer, font?: playdate.graphics.font) -> (width: integer, height: integer);
fun playdate.graphics.getWorkingImage() -> playdate.graphics.image;
fun playdate.graphics.image.new(path: string) -> (image: playdate.graphics.image?, error: string?);
fun playdate.graphics.image.new(width: integer, height: integer, bgcolor?: integer) -> playdate.graphics.image;
fun playdate.graphics.image:addMask(opaque?: boolean) -> nil;
fun playdate.graphics.image:blendWithImage(image: playdate.graphics.image, alpha: number, ditherType: integer) -> playdate.graphics.image;
fun playdate.graphics.image:blurredImage(radius: number, numPasses: integer, ditherType: integer, padEdges?: boolean, xPhase?: integer, yPhase?: integer) -> playdate.graphics.image;
fun playdate.graphics.image:clear(color: integer) -> nil;
fun playdate.graphics.image:clearMask(opaque?: boolean) -> nil;
fun playdate.graphics.image:copy() -> playdate.graphics.image;
fun playdate.graphics.image:draw(p: playdate.geometry.point, flip?: (integer|string), sourceRect?: playdate.geometry.rect) -> nil;
fun playdate.graphics.image:draw(x: integer, y: integer, flip?: (integer|string), sourceRect?: playdate.geometry.rect) -> nil;
fun playdate.graphics.image:drawAnchored(x: integer, y: integer, ax: number, ay: number, flip?: (integer|string)) -> nil;
fun playdate.graphics.image:drawBlurred(x: integer, y: integer, radius: number, numPasses: integer, ditherType: integer, flip?: (integer|string), xPhase?: integer, yPhase?: integer) -> nil;
fun playdate.graphics.image:drawCentered(x: integer, y: integer, flip?: (integer|string)) -> nil;
fun playdate.graphics.image:drawFaded(x: integer, y: integer, alpha: number, ditherType: integer) -> nil;
fun playdate.graphics.image:drawIgnoringOffset(p: playdate.geometry.point, flip?: (integer|string)) -> nil;
fun playdate.graphics.image:drawIgnoringOffset(x: integer, y: integer, flip?: (integer|string)) -> nil;
fun playdate.graphics.image:drawRotated(x: integer, y: integer, angle: number, scale?: integer, yscale?: integer) -> nil;
fun playdate.graphics.image:drawSampled(x: integer, y: integer, width: integer, height: integer, centerx: number, centery: number, dxx: number, dyx: number, dxy: number, dyy: number, dx: integer, dy: integer, z: integer, tiltAngle: number, tile: boolean) -> nil;
fun playdate.graphics.image:drawScaled(x: integer, y: integer, scale: integer, yscale?: integer) -> nil;
fun playdate.graphics.image:drawTiled(rect: playdate.geometry.rect, flip?: (integer|string)) -> nil;
fun playdate.graphics.image:drawTiled(x: integer, y: integer, width: integer, height: integer, flip?: (integer|string)) -> nil;
fun playdate.graphics.image:drawWithTransform(xform: playdate.geometry.affineTransform, x: integer, y: integer) -> nil;
fun playdate.graphics.image:fadedImage(alpha: number, ditherType: integer) -> playdate.graphics.image;
fun playdate.graphics.image:getMaskImage() -> playdate.graphics.image;
fun playdate.graphics.image:getSize() -> (width: integer, height: integer);
fun playdate.graphics.image:hasMask() -> boolean;
fun playdate.graphics.image:invertedImage() -> playdate.graphics.image;
fun playdate.graphics.image:load(path: string) -> (success: boolean, error: string?);
fun playdate.graphics.image:removeMask() -> nil;
fun playdate.graphics.image:rotatedImage(angle: number, scale?: integer, yscale?: integer) -> playdate.graphics.image;
fun playdate.graphics.image:sample(x: integer, y: integer) -> integer;
fun playdate.graphics.image:scaledImage(scale: integer, yscale?: integer) -> playdate.graphics.image;
fun playdate.graphics.image:setInverted(flag: boolean) -> nil;
fun playdate.graphics.image:setMaskImage(maskImage: playdate.graphics.image) -> nil;
fun playdate.graphics.image:transformedImage(xform: playdate.geometry.affineTransform) -> playdate.graphics.image;
fun playdate.graphics.image:vcrPauseFilterImage() -> playdate.graphics.image;
fun playdate.graphics.imageSizeAtPath(path: string) -> (width: integer, height: integer);
fun playdate.graphics.imageWithText(text: string, maxWidth: integer, maxHeight: integer, backgroundColor?: integer, leadingAdjustment?: integer, truncationString?: string, alignment?: integer, font?: playdate.graphics.font) -> (image: playdate.graphics.image, textWasTruncated: boolean);
fun playdate.graphics.imagetable.new(count: integer, cellsWide?: integer, cellSize?: integer) -> playdate.graphics.imagetable;
fun playdate.graphics.imagetable.new(path: string) -> playdate.graphics.imagetable;
fun playdate.graphics.imagetable:__index(n: integer) -> nil;
fun playdate.graphics.imagetable:drawImage(n: integer, x: integer, y: integer, flip?: (integer|string)) -> nil;
fun playdate.graphics.imagetable:getImage(n: integer) -> playdate.graphics.image;
fun playdate.graphics.imagetable:getImage(x: integer, y: integer) -> playdate.graphics.image;
fun playdate.graphics.imagetable:getLength() -> integer;
fun playdate.graphics.imagetable:getSize() -> (cellsWide: integer, cellsHigh: integer);
fun playdate.graphics.imagetable:load(path: string) -> (success: boolean, error: string?);
fun playdate.graphics.imagetable:setImage(n: integer, image: playdate.graphics.image) -> nil;
fun playdate.graphics.lockFocus(image: playdate.graphics.image) -> nil;
fun playdate.graphics.nineSlice.new(imagePath: string, innerX: integer, innerY: integer, innerWidth: integer, innerHeight: integer) -> playdate.graphics.nineSlice;
fun playdate.graphics.nineSlice:drawInRect(rect: playdate.geometry.rect) -> nil;
fun playdate.graphics.nineSlice:drawInRect(x: integer, y: integer, width: integer, height: integer) -> nil;
fun playdate.graphics.nineSlice:getMinSize() -> (width: integer, height: integer);
fun playdate.graphics.nineSlice:getSize() -> (width: integer, height: integer);
fun playdate.graphics.perlin(x: integer, y: integer, z: integer, _repeat: number, octaves?: integer, persistence?: number) -> number;
fun playdate.graphics.perlinArray(count: integer, x: integer, dx: integer, y?: integer, dy?: integer, z?: integer, dz?: integer, _repeat: number, octaves?: integer, persistence?: number) -> number[];
fun playdate.graphics.popContext() -> nil;
fun playdate.graphics.pushContext(image?: playdate.graphics.image) -> nil;
fun playdate.graphics.setBackgroundColor(color: integer) -> nil;
fun playdate.graphics.setClipRect(rect: playdate.geometry.rect) -> nil;
fun playdate.graphics.setClipRect(x: integer, y: integer, width: integer, height: integer) -> nil;
fun playdate.graphics.setColor(color: integer) -> nil;
fun playdate.graphics.setDitherPattern(alpha: number, ditherType?: integer) -> nil;
fun playdate.graphics.setDrawOffset(x: integer, y: integer) -> nil;
fun playdate.graphics.setFont(font: playdate.graphics.font, variant?: (integer|string) -> nil;
fun playdate.graphics.setFontFamily(fontFamily: table<integer, playdate.graphics.font>) -> nil;
fun playdate.graphics.setFontTracking(pixels: integer) -> nil;
fun playdate.graphics.setImageDrawMode(mode: integer) -> nil;
fun playdate.graphics.setLineCapStyle(style: integer) -> nil;
fun playdate.graphics.setLineWidth(width: integer) -> nil;
fun playdate.graphics.setPattern(pattern: integer[]) -> nil;
fun playdate.graphics.setPolygonFillRule(rule: integer) -> nil;
fun playdate.graphics.setScreenClipRect(rect: playdate.geometry.rect) -> nil;
fun playdate.graphics.setScreenClipRect(x: integer, y: integer, width: integer, height: integer) -> nil;
fun playdate.graphics.setStencilImage(image: playdate.graphics.image, tile?: boolean) -> nil;
fun playdate.graphics.setStencilPattern(level: any, ditherType?: integer) -> nil;
fun playdate.graphics.setStencilPattern(pattern: integer[]) -> nil;
fun playdate.graphics.setStencilPattern(row1: integer, row2: integer, row3: integer, row4: integer, row5: integer, row6: integer, row7: integer, row8: integer) -> nil;
fun playdate.graphics.setStrokeLocation(location: integer) -> nil;
fun playdate.graphics.sprite.addDirtyRect(x: integer, y: integer, width: integer, height: integer) -> nil;
fun playdate.graphics.sprite.addEmptyCollisionSprite(r: playdate.geometry.rect) -> nil;
fun playdate.graphics.sprite.addEmptyCollisionSprite(x: integer, y: integer, w: integer, h: integer) -> nil;
fun playdate.graphics.sprite.addSprite(sprite: playdate.graphics.sprite) -> nil;
fun playdate.graphics.sprite.addWallSprites(tilemap: playdate.graphics.tilemap, emptyIDs: integer[], xOffset?: integer, yOffset?: integer) -> nil;
fun playdate.graphics.sprite.allOverlappingSprites() -> playdate.graphics.sprite[][];
fun playdate.graphics.sprite.clearClipRectsInRange(startz: integer, endz: integer) -> nil;
fun playdate.graphics.sprite.getAllSprites() -> playdate.graphics.sprite[];
fun playdate.graphics.sprite.getAlwaysRedraw() -> boolean;
fun playdate.graphics.sprite.new(image_or_tilemap?: playdate.graphics.image|playdate.graphics.tilemap) -> playdate.graphics.sprite;
fun playdate.graphics.sprite.performOnAllSprites(f: fun(sprite: playdate.graphics.sprite)) -> nil;
fun playdate.graphics.sprite.querySpriteInfoAlongLine(lineSegment: playdate.geometry.lineSegment) -> CollisionInfo[];
fun playdate.graphics.sprite.querySpriteInfoAlongLine(x1: integer, y1: integer, x2: integer, y2: integer) -> CollisionInfo[];
fun playdate.graphics.sprite.querySpritesAlongLine(lineSegment: playdate.geometry.lineSegment) -> playdate.graphics.sprite[];
fun playdate.graphics.sprite.querySpritesAlongLine(x1: integer, y1: integer, x2: integer, y2: integer) -> playdate.graphics.sprite[];
fun playdate.graphics.sprite.querySpritesAtPoint(p: playdate.geometry.point) -> playdate.graphics.sprite[];
fun playdate.graphics.sprite.querySpritesAtPoint(x: integer, y: integer) -> playdate.graphics.sprite[];
fun playdate.graphics.sprite.querySpritesInRect(rect: playdate.geometry.rect) -> playdate.graphics.sprite[];
fun playdate.graphics.sprite.querySpritesInRect(x: integer, y: integer, width: integer, height: integer) -> playdate.graphics.sprite[];
fun playdate.graphics.sprite.redrawBackground() -> nil;
fun playdate.graphics.sprite.removeAll() -> nil;
fun playdate.graphics.sprite.removeSprite(sprite: playdate.graphics.sprite) -> nil;
fun playdate.graphics.sprite.removeSprites(spriteArray: playdate.graphics.sprite[]) -> nil;
fun playdate.graphics.sprite.setAlwaysRedraw(flag: boolean) -> nil;
fun playdate.graphics.sprite.setBackgroundDrawingCallback(drawCallback: fun(x: integer, y: integer, width: integer, height: integer): nil) -> nil;
fun playdate.graphics.sprite.setClipRectsInRange(rect: playdate.geometry.rect, startz: integer, endz: integer) -> nil;
fun playdate.graphics.sprite.setClipRectsInRange(x: integer, y: integer, width: integer, height: integer, startz: integer, endz: integer) -> nil;
fun playdate.graphics.sprite.spriteCount() -> integer;
fun playdate.graphics.sprite.spriteWithText(text: string, maxWidth: integer, maxHeight: integer, backgroundColor?: integer, leadingAdjustment?: integer, truncationString?: string, alignment?: integer, font?: playdate.graphics.font) -> playdate.graphics.sprite;
fun playdate.graphics.sprite.update() -> nil;
fun playdate.graphics.sprite:add() -> nil;
fun playdate.graphics.sprite:alphaCollision(anotherSprite: playdate.graphics.sprite) -> boolean;
fun playdate.graphics.sprite:checkCollisions(point: playdate.geometry.point) -> (actualX: integer, actualY: integer, collisions: playdate.graphics.sprite._CollisionData, length: integer);
fun playdate.graphics.sprite:checkCollisions(x: integer, y: integer) -> (actualX: integer, actualY: integer, collisions: playdate.graphics.sprite._CollisionData, length: integer);
fun playdate.graphics.sprite:clearClipRect() -> nil;
fun playdate.graphics.sprite:clearCollideRect() -> nil;
fun playdate.graphics.sprite:clearStencil() -> nil;
fun playdate.graphics.sprite:collisionResponse(other: playdate.graphics.sprite) -> integer;
fun playdate.graphics.sprite:collisionsEnabled() -> boolean;
fun playdate.graphics.sprite:copy() -> playdate.graphics.sprite;
fun playdate.graphics.sprite:draw(x: integer, y: integer, width: integer, height: integer) -> nil;
fun playdate.graphics.sprite:getBounds() -> (x: integer, y: integer, width: integer, height: integer);
fun playdate.graphics.sprite:getBoundsRect() -> playdate.geometry.rect;
fun playdate.graphics.sprite:getCenter() -> (x: number, y: number);
fun playdate.graphics.sprite:getCenterPoint() -> playdate.geometry.point;
fun playdate.graphics.sprite:getCollideBounds() -> (x: integer, y: integer, width: integer, height: integer);
fun playdate.graphics.sprite:getCollideRect() -> playdate.geometry.rect;
fun playdate.graphics.sprite:getCollidesWithGroupsMask() -> integer;
fun playdate.graphics.sprite:getGroupMask() -> integer;
fun playdate.graphics.sprite:getImage() -> playdate.graphics.image;
fun playdate.graphics.sprite:getImageFlip() -> integer;
fun playdate.graphics.sprite:getPosition() -> (x: integer, y: integer);
fun playdate.graphics.sprite:getRotation() -> number;
fun playdate.graphics.sprite:getScale() -> (xScale: integer, yScale: integer);
fun playdate.graphics.sprite:getSize() -> (width: integer, height: integer);
fun playdate.graphics.sprite:getTag() -> integer;
fun playdate.graphics.sprite:getZIndex() -> integer;
fun playdate.graphics.sprite:isOpaque() -> boolean;
fun playdate.graphics.sprite:isVisible() -> boolean;
fun playdate.graphics.sprite:markDirty() -> nil;
fun playdate.graphics.sprite:moveBy(x: integer, y: integer) -> nil;
fun playdate.graphics.sprite:moveTo(x: integer, y: integer) -> nil;
fun playdate.graphics.sprite:moveWithCollisions(goalPoint: playdate.geometry.point) -> (actualX: integer, actualY: integer, collisions: playdate.graphics.sprite._CollisionData, length: integer);
fun playdate.graphics.sprite:moveWithCollisions(goalX: integer, goalY: integer) -> (actualX: integer, actualY: integer, collisions: playdate.graphics.sprite._CollisionData, length: integer);
fun playdate.graphics.sprite:overlappingSprites() -> playdate.graphics.sprite[];
fun playdate.graphics.sprite:remove() -> nil;
fun playdate.graphics.sprite:removeAnimator() -> nil;
fun playdate.graphics.sprite:resetCollidesWithGroupsMask() -> nil;
fun playdate.graphics.sprite:resetGroupMask() -> nil;
fun playdate.graphics.sprite:setAnimator(animator: playdate.graphics.animator, moveWithCollisions?: boolean, removeOnCollision?: boolean) -> nil;
fun playdate.graphics.sprite:setBounds(rect: playdate.geometry.rect) -> nil;
fun playdate.graphics.sprite:setBounds(x: integer, y: integer, width: integer, height: integer) -> nil;
fun playdate.graphics.sprite:setCenter(x: integer, y: integer) -> nil;
fun playdate.graphics.sprite:setClipRect(rect: playdate.geometry.rect) -> nil;
fun playdate.graphics.sprite:setClipRect(x: integer, y: integer, width: integer, height: integer) -> nil;
fun playdate.graphics.sprite:setCollideRect(rect: playdate.geometry.rect) -> nil;
fun playdate.graphics.sprite:setCollideRect(x: integer, y: integer, width: integer, height: integer) -> nil;
fun playdate.graphics.sprite:setCollidesWithGroups(groups: integer|integer[]) -> nil;
fun playdate.graphics.sprite:setCollidesWithGroupsMask(mask: integer) -> nil;
fun playdate.graphics.sprite:setCollisionsEnabled(flag: boolean) -> nil;
fun playdate.graphics.sprite:setGroupMask(mask: integer) -> nil;
fun playdate.graphics.sprite:setGroups(groups: integer|integer[]) -> nil;
fun playdate.graphics.sprite:setIgnoresDrawOffset(flag: boolean) -> nil;
fun playdate.graphics.sprite:setImage(image: playdate.graphics.image, flip?: (integer|string), scale?: integer, yscale?: integer) -> nil;
fun playdate.graphics.sprite:setImageDrawMode(mode: integer) -> nil;
fun playdate.graphics.sprite:setImageFlip(flip: (integer|string), flipCollideRect?: integer) -> nil;
fun playdate.graphics.sprite:setOpaque(flag: boolean) -> nil;
fun playdate.graphics.sprite:setRedrawsOnImageChange(flag: boolean) -> nil;
fun playdate.graphics.sprite:setRotation(angle: number, scale?: integer, yScale?: integer) -> nil;
fun playdate.graphics.sprite:setScale(scale: integer, yScale?: integer) -> nil;
fun playdate.graphics.sprite:setSize(width: integer, height: integer) -> nil;
fun playdate.graphics.sprite:setStencilImage(stencil: playdate.graphics.image, tile?: boolean) -> nil;
fun playdate.graphics.sprite:setStencilPattern(level: any, ditherType?: integer) -> nil;
fun playdate.graphics.sprite:setStencilPattern(pattern: integer[]) -> nil;
fun playdate.graphics.sprite:setTag(tag: integer) -> nil;
fun playdate.graphics.sprite:setTilemap(tilemap: playdate.graphics.tilemap) -> nil;
fun playdate.graphics.sprite:setUpdatesEnabled(flag: boolean) -> nil;
fun playdate.graphics.sprite:setVisible(flag: boolean) -> nil;
fun playdate.graphics.sprite:setZIndex(z: integer) -> nil;
fun playdate.graphics.sprite:update() -> nil;
fun playdate.graphics.sprite:updatesEnabled() -> boolean;
fun playdate.graphics.tilemap.new() -> playdate.graphics.tilemap;
fun playdate.graphics.tilemap:draw(x: integer, y: integer, sourceRect?: playdate.geometry.rect) -> nil;
fun playdate.graphics.tilemap:drawIgnoringOffset(x: integer, y: integer, sourceRect?: playdate.geometry.rect) -> nil;
fun playdate.graphics.tilemap:getCollisionRects(emptyIDs: integer[]) -> playdate.geometry.rect[];
fun playdate.graphics.tilemap:getPixelSize() -> (width: integer, height: integer);
fun playdate.graphics.tilemap:getSize() -> (width: integer, height: integer);
fun playdate.graphics.tilemap:getTileAtPosition(x: integer, y: integer) -> number|nil;
fun playdate.graphics.tilemap:getTileSize() -> (width: integer, height: integer);
fun playdate.graphics.tilemap:getTiles() -> (data: integer[], width: integer);
fun playdate.graphics.tilemap:setImageTable(table: table) -> nil;
fun playdate.graphics.tilemap:setSize(width: integer, height: integer) -> nil;
fun playdate.graphics.tilemap:setTileAtPosition(x: integer, y: integer, index: integer) -> nil;
fun playdate.graphics.tilemap:setTiles(data: integer[], width: integer) -> nil;
fun playdate.graphics.unlockFocus() -> nil;
fun playdate.graphics.video.new(path: string) -> playdate.graphics.video;
fun playdate.graphics.video:getContext() -> playdate.graphics.image;
fun playdate.graphics.video:getFrameCount() -> integer;
fun playdate.graphics.video:getFrameRate() -> number;
fun playdate.graphics.video:getSize() -> (x: integer, y: integer);
fun playdate.graphics.video:renderFrame(number: integer) -> nil;
fun playdate.graphics.video:setContext(image: playdate.graphics.image) -> nil;
fun playdate.graphics.video:useScreenContext() -> nil;
fun playdate.inputHandlers.pop() -> nil;
fun playdate.inputHandlers.push(handler: table, masksPreviousHandlers?: boolean) -> nil;
fun playdate.isCrankDocked() -> boolean;
fun playdate.keyPressed(key: string) -> nil;
fun playdate.keyReleased(key: string) -> nil;
fun playdate.keyboard.hide() -> nil;
fun playdate.keyboard.isVisible() -> nil;
fun playdate.keyboard.keyboardAnimatingCallback() -> nil;
fun playdate.keyboard.keyboardDidHideCallback() -> nil;
fun playdate.keyboard.keyboardDidShowCallback() -> nil;
fun playdate.keyboard.keyboardWillHideCallback() -> nil;
fun playdate.keyboard.left() -> nil;
fun playdate.keyboard.setCapitalizationBehavior(behavior: integer) -> nil;
fun playdate.keyboard.show(text?: string) -> nil;
fun playdate.keyboard.textChangedCallback(ok: boolean) -> nil;
fun playdate.keyboard.width() -> nil;
fun playdate.leftButtonDown() -> nil;
fun playdate.leftButtonUp() -> nil;
fun playdate.math.lerp(min: number, max: number, t: number) -> number;
fun playdate.menu.item:getTitle() -> string;
fun playdate.menu.item:getValue() -> (integer|boolean|string);
fun playdate.menu.item:setCallback(callback: function) -> nil;
fun playdate.menu.item:setTitle(newTitle: string) -> nil;
fun playdate.menu.item:setValue(newValue: (integer|boolean|string)) -> nil;
fun playdate.menu:addCheckmarkMenuItem(title: string, initialValue?: boolean, callback?: function) -> nil;
fun playdate.menu:addMenuItem(title: string, callback: function) -> nil;
fun playdate.menu:addOptionsMenuItem(title: string, options: string[], initalValue?: string, callback?: function) -> nil;
fun playdate.menu:getMenuItems() -> playdate.menu.item[];
fun playdate.menu:removeAllMenuItems() -> nil;
fun playdate.menu:removeMenuItem(menuItem: playdate.menu.item) -> nil;
fun playdate.pathfinder.graph.new(nodeCount?: integer, coordinates?: integer[][]) -> playdate.pathfinder.graph;
fun playdate.pathfinder.graph.new2DGrid(width: integer, height: integer, allowDiagonals?: boolean, includedNodes?: integer[]) -> playdate.pathfinder.graph;
fun playdate.pathfinder.graph:addConnectionToNodeWithID(fromNodeID: integer, toNodeID: integer, weight: number, addReciprocalConnection: boolean) -> nil;
fun playdate.pathfinder.graph:addConnections(connections: integer[][]) -> nil;
fun playdate.pathfinder.graph:addNewNode(id: integer, x?: integer, y?: integer, connectedNodes?: playdate.pathfinder.node[], weights?: number[], addReciprocalConnections?: boolean) -> nil;
fun playdate.pathfinder.graph:addNewNodes(count: integer) -> nil;
fun playdate.pathfinder.graph:addNode(node: playdate.pathfinder.node, connectedNodes?: playdate.pathfinder.node[], weights?: number[], addReciprocalConnections?: boolean) -> nil;
fun playdate.pathfinder.graph:addNodes(nodes: playdate.pathfinder.node[]) -> nil;
fun playdate.pathfinder.graph:allNodes() -> playdate.pathfinder.node[];
fun playdate.pathfinder.graph:findPath(startNode: playdate.pathfinder.node, goalNode: playdate.pathfinder.node, heuristicFunction?: fun(startNode: playdate.pathfinder.node, goalNode: playdate.pathfinder.node) -> integer, findPathToGoalAdjacentNodes?: boolean) -> playdate.pathfinder.node[];
fun playdate.pathfinder.graph:findPathWithIDs(startNodeID: integer, goalNodeID: integer, heuristicFunction?: fun(startNode: playdate.pathfinder.node, goalNode: playdate.pathfinder.node) -> integer, findPathToGoalAdjacentNodes?: boolean) -> integer[];
fun playdate.pathfinder.graph:nodeWithID(id: integer) -> playdate.pathfinder.node?;
fun playdate.pathfinder.graph:nodeWithXY(x: integer, y: integer) -> playdate.pathfinder.node?;
fun playdate.pathfinder.graph:removeAllConnections() -> nil;
fun playdate.pathfinder.graph:removeAllConnectionsFromNodeWithID(id: integer, removeIncoming?: boolean) -> nil;
fun playdate.pathfinder.graph:removeNode(node: playdate.pathfinder.node) -> nil;
fun playdate.pathfinder.graph:removeNodeWithID(id: integer) -> nil;
fun playdate.pathfinder.graph:removeNodeWithXY(x: integer, y: integer) -> nil;
fun playdate.pathfinder.graph:setXYForNodeWithID(id: integer, x: integer, y: integer) -> nil;
fun playdate.pathfinder.node:addConnection(node: playdate.pathfinder.node, weight: number, addReciprocalConnection: boolean) -> nil;
fun playdate.pathfinder.node:addConnectionToNodeWithXY(x: integer, y: integer, weight: number, addReciprocalConnection: boolean) -> nil;
fun playdate.pathfinder.node:addConnections(nodes: playdate.pathfinder.node[], weights: number[], addReciprocalConnections: boolean) -> nil;
fun playdate.pathfinder.node:connectedNodes() -> playdate.pathfinder.node[];
fun playdate.pathfinder.node:removeAllConnections(removeIncoming?: boolean) -> nil;
fun playdate.pathfinder.node:removeConnection(node: playdate.pathfinder.node, removeReciprocal?: boolean) -> nil;
fun playdate.pathfinder.node:setXY(x: integer, y: integer) -> nil;
fun playdate.readAccelerometer() -> (x: number, y: number, z: number);
fun playdate.resetElapsedTime() -> nil;
fun playdate.rightButtonDown() -> nil;
fun playdate.rightButtonUp() -> nil;
fun playdate.setAutoLockDisabled(disable: boolean) -> nil;
fun playdate.setCollectsGarbage(flag: boolean) -> nil;
fun playdate.setCrankSoundsDisabled(disable: boolean) -> nil;
fun playdate.setDebugDrawColor(r: number, g: number, b: number, a: number) -> nil;
fun playdate.setGCScaling(min: number, max: number) -> nil;
fun playdate.setMenuImage(image: playdate.graphics.image, xOffset?: integer) -> nil;
fun playdate.setMinimumGCTime(ms: integer) -> nil;
fun playdate.setNewlinePrinted(flag: boolean) -> nil;
fun playdate.setStatsInterval(seconds: number) -> nil;
fun playdate.shouldDisplay24HourTime() -> boolean;
fun playdate.simulator.exit() -> nil;
fun playdate.simulator.getURL(url: string) -> string;
fun playdate.simulator.writeToFile(image: playdate.graphics.image, path: string) -> nil;
fun playdate.sound.addEffect(effect: playdate.sound.effect) -> nil;
fun playdate.sound.bitcrusher.new() -> playdate.sound.bitcrusher;
fun playdate.sound.bitcrusher:setAmount(amt: number) -> nil;
fun playdate.sound.bitcrusher:setAmountMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.bitcrusher:setMix(level: number) -> nil;
fun playdate.sound.bitcrusher:setMixMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.bitcrusher:setUndersampling(amt: number) -> nil;
fun playdate.sound.bitcrusher:setUndersamplingMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.channel.new() -> playdate.sound.channel;
fun playdate.sound.channel:addEffect(effect: playdate.sound.effect) -> nil;
fun playdate.sound.channel:addSource(source: playdate.sound.source) -> nil;
fun playdate.sound.channel:getVolume() -> number;
fun playdate.sound.channel:remove() -> nil;
fun playdate.sound.channel:removeEffect(effect: playdate.sound.effect) -> nil;
fun playdate.sound.channel:removeSource(source: playdate.sound.source) -> nil;
fun playdate.sound.channel:setPan(pan: number) -> number;
fun playdate.sound.channel:setPanMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.channel:setVolume(volume: number) -> nil;
fun playdate.sound.channel:setVolumeMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.controlsignal.new() -> playdate.sound.controlsignal;
fun playdate.sound.controlsignal:addEvent(event: table) -> nil;
fun playdate.sound.controlsignal:addEvent(step: integer, value: number, interpolate?: boolean) -> nil;
fun playdate.sound.controlsignal:clearEvents() -> nil;
fun playdate.sound.controlsignal:getControllerType() -> integer;
fun playdate.sound.controlsignal:setControllerType(number: integer) -> nil;
fun playdate.sound.delayline.new(length: number) -> playdate.sound.delayline;
fun playdate.sound.delayline:addTap(delay: number) -> nil;
fun playdate.sound.delayline:setFeedback(level: number) -> nil;
fun playdate.sound.delayline:setMix(level: number) -> nil;
fun playdate.sound.delayline:setMixMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.delaylinetap:getVolume() -> number;
fun playdate.sound.delaylinetap:setDelay(time: number) -> nil;
fun playdate.sound.delaylinetap:setDelayMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.delaylinetap:setFlipChannels(flag: boolean) -> nil;
fun playdate.sound.delaylinetap:setVolume(level: number) -> nil;
fun playdate.sound.envelope.new(attack?: number, decay?: number, sustain?: number, release?: number) -> playdate.sound.envelope;
fun playdate.sound.envelope:setAttack(attack: number) -> nil;
fun playdate.sound.envelope:setCurvature(amount: number) -> nil;
fun playdate.sound.envelope:setDecay(decay: number) -> nil;
fun playdate.sound.envelope:setGlobal(flag: boolean) -> nil;
fun playdate.sound.envelope:setLegato(flag: boolean) -> nil;
fun playdate.sound.envelope:setOffset(offset: number) -> nil;
fun playdate.sound.envelope:setRateScaling(scaling: number, start?: number, _end: number) -> nil;
fun playdate.sound.envelope:setRelease(release: number) -> nil;
fun playdate.sound.envelope:setRetrigger(flag: boolean) -> nil;
fun playdate.sound.envelope:setScale(scale: integer) -> nil;
fun playdate.sound.envelope:setSustain(sustain: number) -> nil;
fun playdate.sound.envelope:setVelocitySensitivity(amount: number) -> nil;
fun playdate.sound.envelope:trigger(velocity: number, length?: number) -> nil;
fun playdate.sound.fileplayer.new(buffersize?: number) -> playdate.sound.fileplayer;
fun playdate.sound.fileplayer.new(path: string, buffersize?: number) -> playdate.sound.fileplayer;
fun playdate.sound.fileplayer:didUnderrun() -> boolean;
fun playdate.sound.fileplayer:getLength() -> number;
fun playdate.sound.fileplayer:getOffset() -> number;
fun playdate.sound.fileplayer:getRate() -> number;
fun playdate.sound.fileplayer:getVolume() -> (left_or_mono: number, right: number?);
fun playdate.sound.fileplayer:isPlaying() -> boolean;
fun playdate.sound.fileplayer:load(path: string) -> nil;
fun playdate.sound.fileplayer:pause() -> nil;
fun playdate.sound.fileplayer:play(repeatCount?: integer) -> (success: boolean, error: string?);
fun playdate.sound.fileplayer:setBufferSize(seconds: number) -> nil;
fun playdate.sound.fileplayer:setFinishCallback(func: function, arg?: any) -> nil;
fun playdate.sound.fileplayer:setLoopCallback(callback: function, arg?: any) -> nil;
fun playdate.sound.fileplayer:setLoopRange(start: number, _end: number, loopCallback?: fun(arg?: any): nil, arg?: any) -> nil;
fun playdate.sound.fileplayer:setOffset(seconds: number) -> nil;
fun playdate.sound.fileplayer:setRate(rate: integer) -> nil;
fun playdate.sound.fileplayer:setRateMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.fileplayer:setStopOnUnderrun(flag: boolean) -> nil;
fun playdate.sound.fileplayer:setVolume(left: number, right?: number, fadeSeconds?: number, fadeCallback?: fun(self: playdate.sound.fileplayer, arg?: any), arg?: any) -> nil;
fun playdate.sound.fileplayer:stop() -> nil;
fun playdate.sound.getCurrentTime() -> number;
fun playdate.sound.getHeadphoneState(changeCallback: function) -> (headphone: boolean, mic: boolean?);
fun playdate.sound.getSampleRate() -> integer;
fun playdate.sound.instrument.new(synth?: playdate.sound.synth) -> playdate.sound.instrument;
fun playdate.sound.instrument:addVoice(v: playdate.geometry.vector2D, note?: integer, rangeend?: integer, transpose?: integer) -> nil;
fun playdate.sound.instrument:allNotesOff() -> nil;
fun playdate.sound.instrument:getVolume() -> (left_or_mono: number, right: number?);
fun playdate.sound.instrument:noteOff(note: integer, when?: number) -> nil;
fun playdate.sound.instrument:playMIDINote(note: number|string, vel?: number, length?: number, when?: number) -> nil;
fun playdate.sound.instrument:playNote(frequency: number, vel?: number, length?: number, when?: number) -> nil;
fun playdate.sound.instrument:setTranspose(halfsteps: number) -> nil;
fun playdate.sound.instrument:setVolume(left: integer, right?: integer) -> nil;
fun playdate.sound.lfo.new(type?: integer) -> playdate.sound.lfo;
fun playdate.sound.lfo:setArpeggio(note1: number, ...: number) -> nil;
fun playdate.sound.lfo:setCenter(center: number) -> nil;
fun playdate.sound.lfo:setDelay(holdoff: number, ramp: number) -> nil;
fun playdate.sound.lfo:setDepth(depth: number) -> nil;
fun playdate.sound.lfo:setGlobal(flag: boolean) -> nil;
fun playdate.sound.lfo:setPhase(phase: number) -> nil;
fun playdate.sound.lfo:setRate(rate: number) -> nil;
fun playdate.sound.lfo:setRetrigger(flag: boolean) -> nil;
fun playdate.sound.lfo:setType(type: integer) -> nil;
fun playdate.sound.micinput.getLevel() -> number;
fun playdate.sound.micinput.getSource() -> string;
fun playdate.sound.micinput.recordToSample(buffer: playdate.sound.sample, completionCallback: fun(sample: playdate.sound.sample): nil) -> nil;
fun playdate.sound.micinput.startListening() -> nil;
fun playdate.sound.micinput.stopListening() -> nil;
fun playdate.sound.micinput.stopRecording() -> nil;
fun playdate.sound.onepolefilter.new() -> playdate.sound.onepolefilter;
fun playdate.sound.onepolefilter:setMix(level: number) -> nil;
fun playdate.sound.onepolefilter:setMixMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.onepolefilter:setParameter(p: number) -> nil;
fun playdate.sound.onepolefilter:setParameterMod(m: playdate.sound.signal) -> nil;
fun playdate.sound.overdrive.new() -> playdate.sound.overdrive;
fun playdate.sound.overdrive:setGain(level: number) -> nil;
fun playdate.sound.overdrive:setLimit(level: number) -> nil;
fun playdate.sound.overdrive:setLimitMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.overdrive:setMix(level: number) -> nil;
fun playdate.sound.overdrive:setMixMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.overdrive:setOffset(level: number) -> nil;
fun playdate.sound.overdrive:setOffsetMod(signal: playdate.sound.signaly) -> nil;
fun playdate.sound.playingSources() -> playdate.sound.source[];
fun playdate.sound.removeEffect(effect: playdate.sound.effect) -> nil;
fun playdate.sound.resetTime() -> nil;
fun playdate.sound.ringmod.new() -> playdate.sound.ringmod;
fun playdate.sound.ringmod:setFrequency(f: number) -> nil;
fun playdate.sound.ringmod:setFrequencyMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.ringmod:setMix(level: number) -> nil;
fun playdate.sound.ringmod:setMixMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.sample.new(path: string) -> playdate.sound.sample;
fun playdate.sound.sample:getFormat() -> integer;
fun playdate.sound.sample:getLength() -> (sample_seconds: number, buffer_size_seconds: number);
fun playdate.sound.sample:getSampleRate() -> integer;
fun playdate.sound.sample:getSubsample(startOffset: integer, endOffset: integer) -> playdate.sound.sample;
fun playdate.sound.sample:load(path: string) -> boolean;
fun playdate.sound.sample:play(repeatCount?: integer, rate?: integer) -> nil;
fun playdate.sound.sample:playAt(when: number, vol?: number, rightvol?: number, rate?: integer) -> nil;
fun playdate.sound.sample:save(filename: string) -> nil;
fun playdate.sound.sampleplayer.new(path: string) -> playdate.sound.sampleplayer;
fun playdate.sound.sampleplayer.new(sample: playdate.sound.sample) -> playdate.sound.sampleplayer;
fun playdate.sound.sampleplayer:copy() -> playdate.sound.sampleplayer;
fun playdate.sound.sampleplayer:getLength() -> number;
fun playdate.sound.sampleplayer:getOffset() -> number;
fun playdate.sound.sampleplayer:getRate() -> number;
fun playdate.sound.sampleplayer:getSample() -> playdate.sound.sample;
fun playdate.sound.sampleplayer:getVolume() -> (left_or_mono: number, right: number?);
fun playdate.sound.sampleplayer:isPlaying() -> boolean;
fun playdate.sound.sampleplayer:play(repeatCount?: integer, rate?: integer) -> nil;
fun playdate.sound.sampleplayer:playAt(when: number, vol?: number, rightvol?: number, rate?: integer) -> nil;
fun playdate.sound.sampleplayer:setFinishCallback(func: function, arg?: any) -> nil;
fun playdate.sound.sampleplayer:setLoopCallback(callback: function, arg?: any) -> nil;
fun playdate.sound.sampleplayer:setOffset(seconds: number) -> nil;
fun playdate.sound.sampleplayer:setPaused(flag: boolean) -> nil;
fun playdate.sound.sampleplayer:setPlayRange(start: integer, _end: integer) -> nil;
fun playdate.sound.sampleplayer:setRate(rate: integer) -> nil;
fun playdate.sound.sampleplayer:setRateMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.sampleplayer:setSample(sample: playdate.sound.sample) -> nil;
fun playdate.sound.sampleplayer:setVolume(left: integer, right?: integer) -> nil;
fun playdate.sound.sampleplayer:stop() -> nil;
fun playdate.sound.sequence.new(midi_path: string) -> playdate.sound.sequence;
fun playdate.sound.sequence:addTrack(track?: playdate.sound.track) -> nil;
fun playdate.sound.sequence:allNotesOff() -> nil;
fun playdate.sound.sequence:getCurrentStep() -> number;
fun playdate.sound.sequence:getLength() -> number;
fun playdate.sound.sequence:getTempo() -> number;
fun playdate.sound.sequence:getTrackAtIndex(n: integer) -> playdate.sound.track;
fun playdate.sound.sequence:getTrackCount() -> integer;
fun playdate.sound.sequence:goToStep(step: integer, play?: boolean) -> nil;
fun playdate.sound.sequence:isPlaying() -> boolean;
fun playdate.sound.sequence:play(finishCallback?: fun(self: playdate.sound.sequence): nil) -> nil;
fun playdate.sound.sequence:setLoops(loopCount: integer) -> nil;
fun playdate.sound.sequence:setLoops(startStep: integer, endStep: integer, loopCount?: integer) -> nil;
fun playdate.sound.sequence:setTempo(stepsPerSecond: number) -> nil;
fun playdate.sound.sequence:setTrackAtIndex(n: integer, track: playdate.sound.track) -> nil;
fun playdate.sound.sequence:stop() -> nil;
fun playdate.sound.setOutputsActive(headphones: boolean, speaker: boolean) -> nil;
fun playdate.sound.signal:setOffset(offset: number) -> nil;
fun playdate.sound.signal:setScale(scale: integer) -> nil;
fun playdate.sound.synth.new(sample: playdate.sound.sample, sustainStart?: number, sustainEnd?: number) -> playdate.sound.synth;
fun playdate.sound.synth.new(waveform?: integer) -> playdate.sound.synth;
fun playdate.sound.synth:copy() -> playdate.sound.synth;
fun playdate.sound.synth:getEnvelope() -> playdate.sound.envelope;
fun playdate.sound.synth:getVolume() -> (left_or_mono: number, right: number?);
fun playdate.sound.synth:isPlaying() -> boolean;
fun playdate.sound.synth:noteOff() -> nil;
fun playdate.sound.synth:playMIDINote(note: number|string, volume?: number, length?: number, when?: number) -> boolean;
fun playdate.sound.synth:playNote(pitch: number|string, volume?: number, length?: number, when?: number) -> boolean;
fun playdate.sound.synth:setADSR(attack: number, decay: number, sustain: number, release: number, curvature: number) -> nil;
fun playdate.sound.synth:setAmplitudeMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.synth:setAttack(time: number) -> nil;
fun playdate.sound.synth:setDecay(time: number) -> nil;
fun playdate.sound.synth:setEnvelopeCurvature(amount: number) -> nil;
fun playdate.sound.synth:setFinishCallback(_function: function) -> nil;
fun playdate.sound.synth:setFrequencyMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.synth:setLegato(flag: boolean) -> nil;
fun playdate.sound.synth:setParameter(parameter: integer, value: number) -> nil;
fun playdate.sound.synth:setParameterMod(parameter: integer, signal: playdate.sound.signal) -> nil;
fun playdate.sound.synth:setRelease(time: number) -> nil;
fun playdate.sound.synth:setSustain(level: number) -> nil;
fun playdate.sound.synth:setVolume(left: integer, right?: integer) -> nil;
fun playdate.sound.synth:setWaveform(waveform: integer) -> nil;
fun playdate.sound.synth:stop() -> nil;
fun playdate.sound.track.new() -> playdate.sound.track;
fun playdate.sound.track:addControlSignal(s: playdate.sound.controlsignal) -> nil;
fun playdate.sound.track:addNote(step: integer, note: string|integer, length: number, velocity?: number) -> nil;
fun playdate.sound.track:addNote(table: (playdate.sound.track._SoundTrackNoteIn|playdate.sound.track._SoundTrackNote)) -> nil;
fun playdate.sound.track:clearNotes() -> nil;
fun playdate.sound.track:getControlSignals() -> playdate.sound.controlsignal[];
fun playdate.sound.track:getInstrument() -> playdate.sound.instrument;
fun playdate.sound.track:getLength() -> integer;
fun playdate.sound.track:getNotes(step?: integer, endstep?: integer) -> playdate.sound.track._SoundTrackNote[];
fun playdate.sound.track:getNotesActive() -> integer;
fun playdate.sound.track:getPolyphony() -> integer;
fun playdate.sound.track:removeNote(step: integer, note: integer) -> nil;
fun playdate.sound.track:setInstrument(inst: playdate.sound.instrument) -> nil;
fun playdate.sound.track:setMuted(flag: boolean) -> nil;
fun playdate.sound.track:setNotes(list: table[]) -> nil;
fun playdate.sound.twopolefilter.new(type: integer) -> playdate.sound.twopolefilter;
fun playdate.sound.twopolefilter:setFrequency(f: number) -> nil;
fun playdate.sound.twopolefilter:setFrequencyMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.twopolefilter:setGain(g: number) -> nil;
fun playdate.sound.twopolefilter:setMix(level: number) -> nil;
fun playdate.sound.twopolefilter:setMixMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.twopolefilter:setResonance(r: playdate.geometry.rect) -> nil;
fun playdate.sound.twopolefilter:setResonanceMod(signal: playdate.sound.signal) -> nil;
fun playdate.sound.twopolefilter:setType(type: integer) -> nil;
fun playdate.start() -> nil;
fun playdate.startAccelerometer() -> nil;
fun playdate.stop() -> nil;
fun playdate.stopAccelerometer() -> nil;
fun playdate.string.UUID(length: number) -> string;
fun playdate.string.trimLeadingWhitespace(string: string) -> string;
fun playdate.string.trimTrailingWhitespace(string: string) -> string;
fun playdate.string.trimWhitespace(string: string) -> string;
fun playdate.timeFromEpoch(seconds: integer, milliseconds: integer) -> playdate._DateTime;
fun playdate.timer.allTimers() -> nil;
fun playdate.timer.keyRepeatTimer(callback: function, ...: any) -> nil;
fun playdate.timer.keyRepeatTimerWithDelay(delayAfterInitialFiring: integer, delayAfterSecondFiring: integer, callback: function, ...: any) -> nil;
fun playdate.timer.new(duration: integer, callback: function, ...: any) -> playdate.timer;
fun playdate.timer.new(duration: integer, startValue?: number, endValue?: number, easingFunction?: function) -> nil;
fun playdate.timer.performAfterDelay(delay: integer, callback: function, ...: any) -> nil;
fun playdate.timer.updateCallback(...: any) -> nil;
fun playdate.timer.updateTimers() -> nil;
fun playdate.timer:pause() -> nil;
fun playdate.timer:remove() -> nil;
fun playdate.timer:reset() -> nil;
fun playdate.timer:start() -> nil;
fun playdate.ui.crankIndicator:start() -> nil;
fun playdate.ui.crankIndicator:update() -> nil;
fun playdate.ui.gridview.new(cellWidth: integer, cellHeight: integer) -> playdate.ui.gridview;
fun playdate.ui.gridview:addHorizontalDividerAbove(section: integer, row: integer) -> nil;
fun playdate.ui.gridview:drawCell(section: integer, row: integer, column: integer, selected: boolean, x: integer, y: integer, width: integer, height: integer) -> nil;
fun playdate.ui.gridview:drawHorizontalDivider(x: integer, y: integer, width: integer, height: integer) -> nil;
fun playdate.ui.gridview:drawInRect(x: integer, y: integer, width: integer, height: integer) -> nil;
fun playdate.ui.gridview:drawSectionHeader(section: integer, x: integer, y: integer, width: integer, height: integer) -> nil;
fun playdate.ui.gridview:getCellBounds(section: integer, row: integer, column: integer, gridWidth?: integer) -> (x: integer, y: integer, width: integer, height: integer);
fun playdate.ui.gridview:getHorizontalDividerHeight() -> integer;
fun playdate.ui.gridview:getNumberOfColumns() -> integer;
fun playdate.ui.gridview:getNumberOfRowsInSection(section: integer) -> integer;
fun playdate.ui.gridview:getNumberOfSections() -> integer;
fun playdate.ui.gridview:getScrollPosition() -> (x: integer, y: integer);
fun playdate.ui.gridview:getSectionHeaderHeight() -> integer;
fun playdate.ui.gridview:getSelectedRow() -> integer;
fun playdate.ui.gridview:getSelection() -> (section: integer, row: integer, column: integer);
fun playdate.ui.gridview:removeHorizontalDividers() -> nil;
fun playdate.ui.gridview:scrollCellToCenter(section: integer, row: integer, column: integer, animated?: boolean) -> nil;
fun playdate.ui.gridview:scrollToCell(section: integer, row: integer, column: integer, animated?: boolean) -> nil;
fun playdate.ui.gridview:scrollToRow(row: integer, animated?: boolean) -> nil;
fun playdate.ui.gridview:scrollToTop(animated?: boolean) -> nil;
fun playdate.ui.gridview:selectNextColumn(wrapSelection: boolean, scrollToSelection?: boolean, animate?: boolean) -> nil;
fun playdate.ui.gridview:selectNextRow(wrapSelection: boolean, scrollToSelection?: boolean, animate?: boolean) -> nil;
fun playdate.ui.gridview:selectPreviousColumn(wrapSelection: boolean, scrollToSelection?: boolean, animate?: boolean) -> nil;
fun playdate.ui.gridview:selectPreviousRow(wrapSelection: boolean, scrollToSelection?: boolean, animate?: boolean) -> nil;
fun playdate.ui.gridview:setCellPadding(left: integer, right: integer, top: integer, bottom: integer) -> nil;
fun playdate.ui.gridview:setCellSize(cellWidth: integer, cellHeight: integer) -> nil;
fun playdate.ui.gridview:setContentInset(left: integer, right: integer, top: integer, bottom: integer) -> nil;
fun playdate.ui.gridview:setHorizontalDividerHeight(height: integer) -> nil;
fun playdate.ui.gridview:setNumberOfColumns(num: integer) -> nil;
fun playdate.ui.gridview:setNumberOfRows(...: integer) -> nil;
fun playdate.ui.gridview:setNumberOfRowsInSection(section: integer, num: integer) -> nil;
fun playdate.ui.gridview:setNumberOfSections(num: integer) -> nil;
fun playdate.ui.gridview:setScrollDuration(ms: integer) -> nil;
fun playdate.ui.gridview:setScrollPosition(x: integer, y: integer, animated?: boolean) -> nil;
fun playdate.ui.gridview:setSectionHeaderHeight(height: integer) -> nil;
fun playdate.ui.gridview:setSectionHeaderPadding(left: integer, right: integer, top: integer, bottom: integer) -> nil;
fun playdate.ui.gridview:setSelectedRow(row: integer) -> nil;
fun playdate.ui.gridview:setSelection(section: integer, row: integer, column: integer) -> nil;
fun playdate.upButtonDown() -> nil;
fun playdate.upButtonUp() -> nil;
fun playdate.update() -> nil;
fun playdate.wait(milliseconds: integer) -> nil;
fun print(...: any) -> nil;
fun printTable(table: table) -> nil;
fun sample(name: string, _function: function) -> nil;
fun table.create(arrayCount: integer, hashCount: integer) -> table;
fun table.deepcopy(source: table) -> table;
fun table.getsize(table: table) -> (arrayCount: integer, hashCount: integer);
fun table.indexOfElement(table: table, element: any) -> integer?;
fun table.shallowcopy(source: table, destination?: table) -> table;
fun where() -> string;
